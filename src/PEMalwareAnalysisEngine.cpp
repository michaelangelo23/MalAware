#include "../include/PEMalwareAnalysisEngine.h"
#include "../include/peSectionParser.h"
#include "../include/peImportExport.h"
#include <algorithm>
#include <sstream>

const std::vector<std::string> PEMalwareAnalysisEngine::KNOWN_PACKERS = {
    "UPX", "ASPack", "PECompact", "NSPack", "Themida", "VMProtect", "Armadillo",
    ".aspack", ".upx", ".nsp", ".themida", ".vmp", ".arm", ".petite", ".yoda",
    "PEPACK", "PACKWIN", "ASPR", "Enigma", "ExeCryptor", "FSG", "MEW", "Molebox"
};

const std::vector<std::string> PEMalwareAnalysisEngine::ANTI_DEBUG_IMPORTS = {
    "IsDebuggerPresent", "CheckRemoteDebuggerPresent", "OutputDebugStringA",
    "OutputDebugStringW", "GetTickCount", "QueryPerformanceCounter", "timeGetTime",
    "NtQueryInformationProcess", "NtSetInformationThread", "NtQuerySystemInformation"
};

const std::vector<std::string> PEMalwareAnalysisEngine::ANTI_VM_IMPORTS = {
    "CreateFileA", "CreateFileW", "FindWindowA", "FindWindowW", "GetSystemInfo",
    "GetVersionExA", "GetVersionExW", "RegOpenKeyExA", "RegOpenKeyExW",
    "GetModuleHandleA", "GetModuleHandleW", "LoadLibraryA", "LoadLibraryW"
};

const std::vector<std::string> PEMalwareAnalysisEngine::INJECTION_IMPORTS = {
    "VirtualAllocEx", "WriteProcessMemory", "CreateRemoteThread", "OpenProcess",
    "VirtualProtectEx", "ReadProcessMemory", "SetWindowsHookExA", "SetWindowsHookExW",
    "MapViewOfFile", "UnmapViewOfFile", "NtWriteVirtualMemory", "NtAllocateVirtualMemory"
};

const std::vector<std::string> PEMalwareAnalysisEngine::CRYPTO_IMPORTS = {
    "CryptAcquireContextA", "CryptAcquireContextW", "CryptCreateHash", "CryptEncrypt",
    "CryptDecrypt", "CryptImportKey", "CryptExportKey", "BCryptOpenAlgorithmProvider",
    "BCryptEncrypt", "BCryptDecrypt", "BCryptGenerateSymmetricKey"
};

const std::vector<std::string> PEMalwareAnalysisEngine::NETWORK_IMPORTS = {
    "WSAStartup", "socket", "connect", "send", "recv", "InternetOpenA", "InternetOpenW",
    "InternetConnectA", "InternetConnectW", "HttpOpenRequestA", "HttpOpenRequestW",
    "InternetReadFile", "URLDownloadToFileA", "URLDownloadToFileW"
};

const std::vector<std::string> PEMalwareAnalysisEngine::REGISTRY_IMPORTS = {
    "RegCreateKeyExA", "RegCreateKeyExW", "RegSetValueExA", "RegSetValueExW",
    "RegDeleteKeyA", "RegDeleteKeyW", "RegDeleteValueA", "RegDeleteValueW"
};

const std::vector<std::string> PEMalwareAnalysisEngine::FILE_IMPORTS = {
    "CreateFileA", "CreateFileW", "WriteFile", "ReadFile", "DeleteFileA",
    "DeleteFileW", "MoveFileA", "MoveFileW", "CopyFileA", "CopyFileW",
    "FindFirstFileA", "FindFirstFileW", "SetFileAttributesA", "SetFileAttributesW"
};

int AnalyzeMalware(PPE_FILE_INFO pFileInfo) {
    LOGF("\n[+] MALWARE ANALYSIS ENGINE\n");
    LOGF_DEBUG("[DEBUG] Starting comprehensive malware analysis\n");
    
    if (!pFileInfo || !pFileInfo->pNtHeader) {
        LOGF("[-] ERROR: Invalid PE file info\n");
        return PE_ERROR_INVALID_PE;
    }
    
    try {
        auto result = PEMalwareAnalysisEngine::analyzeFile(pFileInfo);
        PEMalwareAnalysisEngine::logMalwareAnalysis(result);
        
        LOGF("[+] Malware analysis completed successfully!\n");
        return PE_SUCCESS;
    }
    catch (const std::exception& e) {
        LOGF("[-] ERROR: Malware analysis failed: %s\n", e.what());
        return PE_ERROR_PARSING;
    }
}

PEMalwareAnalysisEngine::MalwareAnalysisResult PEMalwareAnalysisEngine::analyzeFile(PPE_FILE_INFO pFileInfo) {
    MalwareAnalysisResult result = {};
    result.isSuspicious = false;
    result.riskScore = 0;
    
    if (!pFileInfo) {
        result.classification = "Analysis Failed";
        result.recommendation = "Unable to analyze file";
        return result;
    }
    
    auto packerIndicators = detectPackers(pFileInfo);
    auto antiAnalysisIndicators = detectAntiAnalysis(pFileInfo);
    auto importIndicators = detectSuspiciousImports(pFileInfo);
    auto sectionIndicators = detectSuspiciousSections(pFileInfo);
    auto obfuscationIndicators = detectObfuscation(pFileInfo);
    
    result.indicators.insert(result.indicators.end(), packerIndicators.begin(), packerIndicators.end());
    result.indicators.insert(result.indicators.end(), antiAnalysisIndicators.begin(), antiAnalysisIndicators.end());
    result.indicators.insert(result.indicators.end(), importIndicators.begin(), importIndicators.end());
    result.indicators.insert(result.indicators.end(), sectionIndicators.begin(), sectionIndicators.end());
    result.indicators.insert(result.indicators.end(), obfuscationIndicators.begin(), obfuscationIndicators.end());
    
    result.riskScore = calculateRiskScore(result.indicators);
    result.isSuspicious = result.riskScore > 30 || hasHighSeverityIndicators(result.indicators);
    
    result.classification = classifyMalware(result);
    result.recommendation = generateRecommendation(result.riskScore, result.classification);
    
    result.metadata["architecture"] = pFileInfo->bIs64Bit ? "x64" : "x86";
    result.metadata["total_indicators"] = std::to_string(result.indicators.size());
    result.metadata["analysis_version"] = "1.0";
    
    return result;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectPackers(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;
    
    if (!pFileInfo) return indicators;
    
    extern int g_NumberOfSections;
    extern PIMAGE_SECTION_HEADER g_SectionHeader;
    
    if (!g_SectionHeader) return indicators;
    
    for (int i = 0; i < g_NumberOfSections; i++) {
        char sectionName[9] = {0};
        strncpy(sectionName, (char*)g_SectionHeader[i].Name, 8);
        
        for (const auto& packer : KNOWN_PACKERS) {
            if (strstr(sectionName, packer.c_str()) != nullptr) {
                MalwareIndicator indicator;
                indicator.category = "Packer Detection";
                indicator.description = "Known packer signature detected";
                indicator.severity = 7;
                indicator.evidence = "Section name: " + std::string(sectionName) + " (matches " + packer + ")";
                indicator.isDetected = true;
                indicators.push_back(indicator);
            }
        }
    }
    
    if (isSuspiciousEntryPoint(pFileInfo)) {
        MalwareIndicator indicator;
        indicator.category = "Packer Detection";
        indicator.description = "Entry point in suspicious section";
        indicator.severity = 6;
        indicator.evidence = "Entry point not in .text section";
        indicator.isDetected = true;
        indicators.push_back(indicator);
    }
    
    return indicators;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectAntiAnalysis(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;
    
    if (!pFileInfo) return indicators;
    
    if (hasAntiDebugImports(pFileInfo)) {
        MalwareIndicator indicator;
        indicator.category = "Anti-Analysis";
        indicator.description = "Anti-debugging imports detected";
        indicator.severity = 8;
        indicator.evidence = "Functions like IsDebuggerPresent, CheckRemoteDebuggerPresent found";
        indicator.isDetected = true;
        indicators.push_back(indicator);
    }
    
    if (hasAntiVMImports(pFileInfo)) {
        MalwareIndicator indicator;
        indicator.category = "Anti-Analysis";
        indicator.description = "Anti-VM detection patterns found";
        indicator.severity = 7;
        indicator.evidence = "VM detection techniques present";
        indicator.isDetected = true;
        indicators.push_back(indicator);
    }
    
    return indicators;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectSuspiciousImports(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;
    
    if (!pFileInfo) return indicators;
    
    if (hasInjectionIndicators(pFileInfo)) {
        MalwareIndicator indicator;
        indicator.category = "Suspicious Imports";
        indicator.description = "Process injection capabilities detected";
        indicator.severity = 9;
        indicator.evidence = "VirtualAllocEx, WriteProcessMemory, CreateRemoteThread found";
        indicator.isDetected = true;
        indicators.push_back(indicator);
    }
    
    if (hasHollowingIndicators(pFileInfo)) {
        MalwareIndicator indicator;
        indicator.category = "Suspicious Imports";
        indicator.description = "Process hollowing capabilities detected";
        indicator.severity = 9;
        indicator.evidence = "Process manipulation functions found";
        indicator.isDetected = true;
        indicators.push_back(indicator);
    }
    
    return indicators;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectSuspiciousSections(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;
    
    if (!pFileInfo) return indicators;
    
    extern int g_NumberOfSections;
    extern PIMAGE_SECTION_HEADER g_SectionHeader;
    
    if (!g_SectionHeader) return indicators;
    
    if (hasCodeInDataSections(pFileInfo)) {
        MalwareIndicator indicator;
        indicator.category = "Suspicious Sections";
        indicator.description = "Executable code in data sections";
        indicator.severity = 7;
        indicator.evidence = "High entropy in non-executable sections";
        indicator.isDetected = true;
        indicators.push_back(indicator);
    }
    
    for (int i = 0; i < g_NumberOfSections; i++) {
        char sectionName[9] = {0};
        strncpy(sectionName, (char*)g_SectionHeader[i].Name, 8);
        
        if (strlen(sectionName) > 0 && 
            strcmp(sectionName, ".text") != 0 &&
            strcmp(sectionName, ".data") != 0 &&
            strcmp(sectionName, ".rdata") != 0 &&
            strcmp(sectionName, ".rsrc") != 0 &&
            strcmp(sectionName, ".reloc") != 0 &&
            strcmp(sectionName, ".idata") != 0 &&
            strcmp(sectionName, ".didata") != 0 &&
            strcmp(sectionName, ".pdata") != 0 &&
            strcmp(sectionName, ".xdata") != 0 &&
            strcmp(sectionName, ".ndata") != 0 &&
            strcmp(sectionName, ".tls") != 0) {
            
            bool hasDigits = false;
            bool hasLower = false;
            bool hasUpper = false;
            bool hasSpecialChars = false;
            
            for (int j = 0; sectionName[j]; j++) {
                if (isdigit(sectionName[j])) hasDigits = true;
                if (islower(sectionName[j])) hasLower = true;
                if (isupper(sectionName[j])) hasUpper = true;
                if (!isalnum(sectionName[j]) && sectionName[j] != '.' && sectionName[j] != '_') hasSpecialChars = true;
            }
            
            if ((hasDigits && hasLower && hasUpper) || hasSpecialChars || strlen(sectionName) > 8) {
                MalwareIndicator indicator;
                indicator.category = "Suspicious Sections";
                indicator.description = "Unusual section name detected";
                indicator.severity = 4;
                indicator.evidence = "Section name: " + std::string(sectionName);
                indicator.isDetected = true;
                indicators.push_back(indicator);
            }
        }
    }
    
    return indicators;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectObfuscation(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;
    
    if (!pFileInfo) return indicators;
    
    extern int g_CorruptedImports;
    extern int g_InvalidDLLNames;
    
    if (g_CorruptedImports > 50 || g_InvalidDLLNames > 2) {
        MalwareIndicator indicator;
        indicator.category = "Obfuscation";
        indicator.description = "Import table obfuscation detected";
        indicator.severity = 8;
        indicator.evidence = "Corrupted import table entries detected during parsing";
        indicator.isDetected = true;
        indicators.push_back(indicator);
    }
    
    return indicators;
}

int PEMalwareAnalysisEngine::calculateRiskScore(const std::vector<MalwareIndicator>& indicators) {
    int score = 0;
    
    for (const auto& indicator : indicators) {
        if (indicator.isDetected) {
            if (indicator.category == "Packer Detection") {
                score += PACKER_WEIGHT;
            } else if (indicator.category == "Anti-Analysis") {
                score += ANTI_ANALYSIS_WEIGHT;
            } else if (indicator.category == "Suspicious Imports") {
                score += SUSPICIOUS_IMPORTS_WEIGHT;
            } else if (indicator.category == "Suspicious Sections") {
                score += SUSPICIOUS_SECTIONS_WEIGHT;
            } else if (indicator.category == "Obfuscation") {
                score += OBFUSCATION_WEIGHT;
            }
        }
    }
    
    return std::min(score, 100); 
}

std::string PEMalwareAnalysisEngine::classifyMalware(const MalwareAnalysisResult& result) {
    if (result.riskScore <= 10) {
        return "Clean/Low Risk";
    } else if (result.riskScore <= 40) {
        return "Suspicious";
    } else if (result.riskScore <= 70) {
        return "Likely Malware";
    } else {
        return "High Risk Malware";
    }
}

std::string PEMalwareAnalysisEngine::generateRecommendation(int riskScore, const std::string& classification) {
    if (riskScore <= 10) {
        return "File appears clean. Standard security practices apply.";
    } else if (riskScore <= 40) {
        return "Exercise caution. Consider additional analysis with behavioral tools.";
    } else if (riskScore <= 70) {
        return "High risk file. Recommend sandboxed analysis and avoid execution.";
    } else {
        return "DANGEROUS: Do not execute. Quarantine and analyze in isolated environment.";
    }
}

void PEMalwareAnalysisEngine::logMalwareAnalysis(const MalwareAnalysisResult& analysisResult) {
    LOGF("\tRisk Score: %d/100\n", analysisResult.riskScore);
    LOGF("\tClassification: %s\n", analysisResult.classification.c_str());
    LOGF("\tSuspicious: %s\n", analysisResult.isSuspicious ? "YES" : "NO");
    
    if (!analysisResult.indicators.empty()) {
        LOGF("\tThreat Indicators (%zu found):\n", analysisResult.indicators.size());
        
        for (const auto& indicator : analysisResult.indicators) {
            if (indicator.isDetected) {
                LOGF("\t\t[%s] %s (Severity: %d/10)\n", 
                     indicator.category.c_str(),
                     indicator.description.c_str(),
                     indicator.severity);
                if (!indicator.evidence.empty()) {
                    LOGF("\t\t    Evidence: %s\n", indicator.evidence.c_str());
                }
            }
        }
    } else {
        LOGF("\tThreat Indicators: None detected\n");
    }
    
    LOGF("\tRecommendation: %s\n", analysisResult.recommendation.c_str());
}

bool PEMalwareAnalysisEngine::hasHighSeverityIndicators(const std::vector<MalwareIndicator>& indicators) {
    for (const auto& indicator : indicators) {
        if (indicator.severity >= 8) {
            return true;
        }
    }
    return false;
}

bool PEMalwareAnalysisEngine::isSuspiciousEntryPoint(PPE_FILE_INFO pFileInfo) {
    return false;
}

bool PEMalwareAnalysisEngine::hasAntiDebugImports(PPE_FILE_INFO pFileInfo) {
    return false;
}

bool PEMalwareAnalysisEngine::hasAntiVMImports(PPE_FILE_INFO pFileInfo) {
    return false;
}

bool PEMalwareAnalysisEngine::hasInjectionIndicators(PPE_FILE_INFO pFileInfo) {
    return false;
}

bool PEMalwareAnalysisEngine::hasHollowingIndicators(PPE_FILE_INFO pFileInfo) {
    return false;
}

bool PEMalwareAnalysisEngine::hasCodeInDataSections(PPE_FILE_INFO pFileInfo) {
    return false;
}
