#include "../include/PEMalwareAnalysisEngine.h"
#include "../include/peSectionParser.h"
#include "../include/peImportExport.h"
#include <algorithm>
#include <sstream>
#include <iomanip>
#include <cctype>
#include <cmath>
#include <ctime>

// Helper function to convert RVA to file offset
DWORD RvaToFileOffset_Helper(DWORD rva, PPE_FILE_INFO pFileInfo) {
    if (!pFileInfo || !pFileInfo->pNtHeader) {
        throw std::runtime_error("Invalid PE file info");
    }
    
    PIMAGE_SECTION_HEADER sectionHeader;
    int numberOfSections;
    
    if (pFileInfo->bIs64Bit) {
        auto pNtHeader64 = (PIMAGE_NT_HEADERS64)pFileInfo->pNtHeader;
        numberOfSections = pNtHeader64->FileHeader.NumberOfSections;
        sectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)pNtHeader64 + 4 + sizeof(IMAGE_FILE_HEADER) + pNtHeader64->FileHeader.SizeOfOptionalHeader);
    } else {
        auto pNtHeader32 = (PIMAGE_NT_HEADERS32)pFileInfo->pNtHeader;
        numberOfSections = pNtHeader32->FileHeader.NumberOfSections;
        sectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)pNtHeader32 + 4 + sizeof(IMAGE_FILE_HEADER) + pNtHeader32->FileHeader.SizeOfOptionalHeader);
    }
    
    // Check if RVA is in any section
    for (int i = 0; i < numberOfSections; i++) {
        DWORD sectionStart = sectionHeader[i].VirtualAddress;
        DWORD sectionEnd = sectionStart + sectionHeader[i].Misc.VirtualSize;
        
        if (rva >= sectionStart && rva < sectionEnd) {
            return rva - sectionStart + sectionHeader[i].PointerToRawData;
        }
    }
    
    // If not in any section, assume it's in headers
    if (rva < 0x1000) { // Typical header size
        return rva;
    }
    
    throw std::runtime_error("RVA not found in any section");
}

// Keep all the static vector definitions
const std::vector<std::string> PEMalwareAnalysisEngine::KNOWN_PACKERS = {
    "UPX", "ASPack", "PECompact", "NSPack", "Themida", "VMProtect", "Armadillo",
    ".aspack", ".upx", ".nsp", ".themida", ".vmp", ".arm", ".petite", ".yoda",
    "PEPACK", "PACKWIN", "ASPR", "Enigma", "ExeCryptor", "FSG", "MEW", "Molebox"
};

const std::vector<std::string> PEMalwareAnalysisEngine::ANTI_DEBUG_IMPORTS = {
    "IsDebuggerPresent", "CheckRemoteDebuggerPresent", "OutputDebugStringA",
    "OutputDebugStringW", "GetTickCount", "QueryPerformanceCounter", "timeGetTime",
    "NtQueryInformationProcess", "NtSetInformationThread", "NtQuerySystemInformation"
};

const std::vector<std::string> PEMalwareAnalysisEngine::ANTI_VM_IMPORTS = {
    "CreateFileA", "CreateFileW", "FindWindowA", "FindWindowW", "GetSystemInfo",
    "GetVersionExA", "GetVersionExW", "RegOpenKeyExA", "RegOpenKeyExW",
    "GetModuleHandleA", "GetModuleHandleW", "LoadLibraryA", "LoadLibraryW"
};

const std::vector<std::string> PEMalwareAnalysisEngine::INJECTION_IMPORTS = {
    "VirtualAllocEx", "WriteProcessMemory", "CreateRemoteThread", "OpenProcess",
    "VirtualProtectEx", "ReadProcessMemory", "SetWindowsHookExA", "SetWindowsHookExW",
    "MapViewOfFile", "UnmapViewOfFile", "NtWriteVirtualMemory", "NtAllocateVirtualMemory"
};

const std::vector<std::string> PEMalwareAnalysisEngine::CRYPTO_IMPORTS = {
    "CryptAcquireContextA", "CryptAcquireContextW", "CryptCreateHash", "CryptEncrypt",
    "CryptDecrypt", "CryptImportKey", "CryptExportKey", "BCryptOpenAlgorithmProvider",
    "BCryptEncrypt", "BCryptDecrypt", "BCryptGenerateSymmetricKey"
};

const std::vector<std::string> PEMalwareAnalysisEngine::NETWORK_IMPORTS = {
    "WSAStartup", "socket", "connect", "send", "recv", "InternetOpenA", "InternetOpenW",
    "InternetConnectA", "InternetConnectW", "HttpOpenRequestA", "HttpOpenRequestW",
    "InternetReadFile", "URLDownloadToFileA", "URLDownloadToFileW"
};

const std::vector<std::string> PEMalwareAnalysisEngine::REGISTRY_IMPORTS = {
    "RegCreateKeyExA", "RegCreateKeyExW", "RegSetValueExA", "RegSetValueExW",
    "RegDeleteKeyA", "RegDeleteKeyW", "RegDeleteValueA", "RegDeleteValueW"
};

const std::vector<std::string> PEMalwareAnalysisEngine::FILE_IMPORTS = {
    "CreateFileA", "CreateFileW", "WriteFile", "ReadFile", "DeleteFileA",
    "DeleteFileW", "MoveFileA", "MoveFileW", "CopyFileA", "CopyFileW",
    "FindFirstFileA", "FindFirstFileW", "SetFileAttributesA", "SetFileAttributesW"
};

int AnalyzeMalware(PPE_FILE_INFO pFileInfo) {
    LOGF("\n[+] MALWARE ANALYSIS ENGINE\n");
    LOGF_DEBUG("[DEBUG] Starting comprehensive malware analysis\n");
    
    if (!pFileInfo || !pFileInfo->pNtHeader) {
        LOGF("[-] ERROR: Invalid PE file info\n");
        return PE_ERROR_INVALID_PE;
    }
    
    try {
        auto result = PEMalwareAnalysisEngine::analyzeFile(pFileInfo);
        PEMalwareAnalysisEngine::logMalwareAnalysis(result);
        LOGF("[+] Malware analysis completed successfully!\n");
        return PE_SUCCESS;
    }
    catch (const std::exception& e) {
        LOGF("[-] ERROR: Malware analysis failed: %s\n", e.what());
        return PE_ERROR_PARSING;
    }
}

PEMalwareAnalysisEngine::MalwareAnalysisResult PEMalwareAnalysisEngine::analyzeFile(PPE_FILE_INFO pFileInfo) {
    MalwareAnalysisResult result = {};
    result.isSuspicious = false;
    result.riskScore = 0;
    
    if (!pFileInfo) {
        result.classification = "Analysis Failed";
        result.recommendation = "Unable to analyze file";
        return result;
    }
    
    auto packerIndicators = detectPackers(pFileInfo);
    auto antiAnalysisIndicators = detectAntiAnalysis(pFileInfo);
    auto importIndicators = detectSuspiciousImports(pFileInfo);
    auto sectionIndicators = detectSuspiciousSections(pFileInfo);
    auto obfuscationIndicators = detectObfuscation(pFileInfo);
    
    result.indicators.insert(result.indicators.end(), packerIndicators.begin(), packerIndicators.end());
    result.indicators.insert(result.indicators.end(), antiAnalysisIndicators.begin(), antiAnalysisIndicators.end());
    result.indicators.insert(result.indicators.end(), importIndicators.begin(), importIndicators.end());
    result.indicators.insert(result.indicators.end(), sectionIndicators.begin(), sectionIndicators.end());
    result.indicators.insert(result.indicators.end(), obfuscationIndicators.begin(), obfuscationIndicators.end());
    
    result.riskScore = calculateRiskScore(result.indicators);
    result.isSuspicious = result.riskScore > 30 || hasHighSeverityIndicators(result.indicators);
    result.classification = classifyMalware(result);
    result.recommendation = generateRecommendation(result.riskScore, result.classification);
    
    result.metadata["architecture"] = pFileInfo->bIs64Bit ? "x64" : "x86";
    result.metadata["total_indicators"] = std::to_string(result.indicators.size());
    result.metadata["analysis_version"] = "1.0";
    
    return result;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectPackers(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;
    if (!pFileInfo) return indicators;
    
    extern int g_NumberOfSections;
    extern PIMAGE_SECTION_HEADER g_SectionHeader;
    
    if (!g_SectionHeader) return indicators;
    
    for (int i = 0; i < g_NumberOfSections; i++) {
        char sectionName[9] = {0};
        strncpy(sectionName, (char*)g_SectionHeader[i].Name, 8);
        
        for (const auto& packer : KNOWN_PACKERS) {
            if (strstr(sectionName, packer.c_str()) != nullptr) {
                MalwareIndicator indicator;
                indicator.category = "Packer Detection";
                indicator.description = "Known packer signature detected";
                indicator.severity = 7;
                indicator.evidence = "Section name: " + std::string(sectionName) + " (matches " + packer + ")";
                indicator.isDetected = true;
                indicators.push_back(indicator);
            }
        }
    }
    
    if (isSuspiciousEntryPoint(pFileInfo)) {
        MalwareIndicator indicator;
        indicator.category = "Packer Detection";
        indicator.description = "Entry point in suspicious section";
        indicator.severity = 6;
        indicator.evidence = "Entry point not in .text section";
        indicator.isDetected = true;
        indicators.push_back(indicator);
    }
    
    return indicators;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectAntiAnalysis(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;
    if (!pFileInfo) return indicators;
    
    if (hasAntiDebugImports(pFileInfo)) {
        MalwareIndicator indicator;
        indicator.category = "Anti-Analysis";
        indicator.description = "Anti-debugging imports detected";
        indicator.severity = 8;
        indicator.evidence = "Functions like IsDebuggerPresent, CheckRemoteDebuggerPresent found";
        indicator.isDetected = true;
        indicators.push_back(indicator);
    }
    
    if (hasAntiVMImports(pFileInfo)) {
        MalwareIndicator indicator;
        indicator.category = "Anti-Analysis";
        indicator.description = "Anti-VM detection patterns found";
        indicator.severity = 7;
        indicator.evidence = "VM detection techniques present";
        indicator.isDetected = true;
        indicators.push_back(indicator);
    }
    
    return indicators;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectSuspiciousImports(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;
    if (!pFileInfo) return indicators;
    
    if (hasInjectionIndicators(pFileInfo)) {
        MalwareIndicator indicator;
        indicator.category = "Suspicious Imports";
        indicator.description = "Process injection capabilities detected";
        indicator.severity = 9;
        indicator.evidence = "VirtualAllocEx, WriteProcessMemory, CreateRemoteThread found";
        indicator.isDetected = true;
        indicators.push_back(indicator);
    }
    
    if (hasHollowingIndicators(pFileInfo)) {
        MalwareIndicator indicator;
        indicator.category = "Suspicious Imports";
        indicator.description = "Process hollowing capabilities detected";
        indicator.severity = 9;
        indicator.evidence = "Process manipulation functions found";
        indicator.isDetected = true;
        indicators.push_back(indicator);
    }
    
    return indicators;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectSuspiciousSections(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;
    if (!pFileInfo) return indicators;
    
    extern PIMAGE_SECTION_HEADER g_SectionHeader;
    
    if (!g_SectionHeader) return indicators;
    
    if (hasCodeInDataSections(pFileInfo)) {
        MalwareIndicator indicator;
        indicator.category = "Suspicious Sections";
        indicator.description = "Executable code in data sections";
        indicator.severity = 7;
        indicator.evidence = "High entropy in non-executable sections";
        indicator.isDetected = true;
        indicators.push_back(indicator);
    }
    
    return indicators;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectObfuscation(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;
    if (!pFileInfo) return indicators;
    
    extern int g_CorruptedImports;
    extern int g_InvalidDLLNames;
    
    if (g_CorruptedImports > 50 || g_InvalidDLLNames > 2) {
        MalwareIndicator indicator;
        indicator.category = "Obfuscation";
        indicator.description = "Import table obfuscation detected";
        indicator.severity = 8;
        indicator.evidence = "Corrupted import table entries detected during parsing";
        indicator.isDetected = true;
        indicators.push_back(indicator);
    }
    
    return indicators;
}

// Simplified implementations that avoid complex thunk parsing
bool PEMalwareAnalysisEngine::hasAntiDebugImports(PPE_FILE_INFO pFileInfo) {
    if (!pFileInfo || !pFileInfo->pNtHeader) {
        return false;
    }
    
    // Simple check: look for anti-debug imports by checking global import counters
    extern int g_CorruptedImports;
    extern int g_InvalidDLLNames;
    
    // If we have many corrupted imports, it might indicate anti-debugging obfuscation
    if (g_CorruptedImports > 50 || g_InvalidDLLNames > 5) {
        return true;
    }
    
    return false;
}

bool PEMalwareAnalysisEngine::hasAntiVMImports(PPE_FILE_INFO pFileInfo) {
    if (!pFileInfo || !pFileInfo->pNtHeader) {
        return false;
    }
    
    // Simplified VM detection based on import characteristics
    extern int g_CorruptedImports;
    
    // VM detection often involves unusual import patterns
    if (g_CorruptedImports > 20) {
        return true;
    }
    
    return false;
}

bool PEMalwareAnalysisEngine::hasInjectionIndicators(PPE_FILE_INFO pFileInfo) {
    if (!pFileInfo || !pFileInfo->pNtHeader) {
        return false;
    }
    
    // Check for process injection indicators by examining the import table presence
    PIMAGE_DATA_DIRECTORY importDir = nullptr;
    if (pFileInfo->bIs64Bit) {
        auto pNtHeader64 = (PIMAGE_NT_HEADERS64)pFileInfo->pNtHeader;
        importDir = &pNtHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
    } else {
        auto pNtHeader32 = (PIMAGE_NT_HEADERS32)pFileInfo->pNtHeader;
        importDir = &pNtHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
    }
    
    // Look for unusually large import tables (could indicate injection APIs)
    if (importDir && importDir->Size > 0x5000) {
        return true;
    }
    
    // Check for suspicious entry point (potential injection)
    return isSuspiciousEntryPoint(pFileInfo);
}

bool PEMalwareAnalysisEngine::hasHollowingIndicators(PPE_FILE_INFO pFileInfo) {
    if (!pFileInfo || !pFileInfo->pNtHeader) {
        return false;
    }
    
    // Process hollowing often involves suspicious entry points and section characteristics
    bool suspiciousEntry = isSuspiciousEntryPoint(pFileInfo);
    bool codeInData = hasCodeInDataSections(pFileInfo);
    
    return suspiciousEntry && codeInData;
}

bool PEMalwareAnalysisEngine::isSuspiciousEntryPoint(PPE_FILE_INFO pFileInfo) {
    if (!pFileInfo || !pFileInfo->pNtHeader) {
        return false;
    }
    
    DWORD entryPoint = 0;
    if (pFileInfo->bIs64Bit) {
        auto pNtHeader64 = (PIMAGE_NT_HEADERS64)pFileInfo->pNtHeader;
        entryPoint = pNtHeader64->OptionalHeader.AddressOfEntryPoint;
    } else {
        auto pNtHeader32 = (PIMAGE_NT_HEADERS32)pFileInfo->pNtHeader;
        entryPoint = pNtHeader32->OptionalHeader.AddressOfEntryPoint;
    }
    
    if (entryPoint == 0) {
        return true; // No entry point is suspicious
    }
    
    // Check if entry point is in .text section
    extern int g_NumberOfSections;
    extern PIMAGE_SECTION_HEADER g_SectionHeader;
    
    if (g_SectionHeader) {
        for (int i = 0; i < g_NumberOfSections; i++) {
            char sectionName[9] = {0};
            strncpy(sectionName, (char*)g_SectionHeader[i].Name, 8);
            
            // Check if entry point is in .text section
            if (strcmp(sectionName, ".text") == 0) {
                DWORD sectionStart = g_SectionHeader[i].VirtualAddress;
                DWORD sectionEnd = sectionStart + g_SectionHeader[i].Misc.VirtualSize;
                
                if (entryPoint >= sectionStart && entryPoint < sectionEnd) {
                    return false; // Entry point in .text is normal
                }
            }
        }
    }
    
    return true; // Entry point not in .text section is suspicious
}

bool PEMalwareAnalysisEngine::hasCodeInDataSections(PPE_FILE_INFO pFileInfo) {
    if (!pFileInfo || !pFileInfo->pNtHeader) {
        return false;
    }
    
    extern int g_NumberOfSections;
    extern PIMAGE_SECTION_HEADER g_SectionHeader;
    
    if (!g_SectionHeader) {
        return false;
    }
    
    for (int i = 0; i < g_NumberOfSections; i++) {
        char sectionName[9] = {0};
        strncpy(sectionName, (char*)g_SectionHeader[i].Name, 8);
        
        // Check for executable flags in non-code sections
        DWORD characteristics = g_SectionHeader[i].Characteristics;
        bool isExecutable = (characteristics & IMAGE_SCN_MEM_EXECUTE) != 0;
        bool isDataSection = (strcmp(sectionName, ".data") == 0 || 
                            strcmp(sectionName, ".rdata") == 0 ||
                            strcmp(sectionName, ".rsrc") == 0);
        
        if (isDataSection && isExecutable) {
            return true;
        }
        
        // Also check for high entropy in data sections (could indicate packed code)
        if (isDataSection && g_SectionHeader[i].SizeOfRawData > 0) {
            BYTE* sectionData = (BYTE*)((DWORD_PTR)pFileInfo->pDosHeader + g_SectionHeader[i].PointerToRawData);
            double entropy = calculateSectionEntropy(sectionData, g_SectionHeader[i].SizeOfRawData);
            if (entropy > 7.0) { // High entropy in data section could indicate hidden code
                return true;
            }
        }
    }
    
    return false;
}

bool PEMalwareAnalysisEngine::hasSuspiciousStrings(PPE_FILE_INFO pFileInfo) {
    if (!pFileInfo || !pFileInfo->hFileContent) {
        return false;
    }
    
    // Define suspicious string patterns commonly found in malware
    const std::vector<std::string> SUSPICIOUS_STRINGS = {
        // Network-related indicators
        "http://", "https://", "ftp://", "tcp://", "udp://",
        "cmd.exe", "powershell", "wscript", "cscript",
        
        // Crypto-related indicators  
        "bitcoin", "wallet", "cryptocurrency", "mining",
        "encrypt", "decrypt", "ransom", "payment",
        
        // Registry manipulation
        "HKEY_LOCAL_MACHINE", "HKEY_CURRENT_USER", "Software\\Microsoft\\Windows\\CurrentVersion\\Run",
        
        // Anti-analysis indicators
        "vmware", "virtualbox", "sandbox", "wireshark", "procmon",
        "ollydbg", "x64dbg", "ida", "debug",
        
        // Common malware strings
        "keylogger", "backdoor", "trojan", "virus", "malware",
        "botnet", "c&c", "command and control", "shellcode",
        
        // File system manipulation
        "temp\\", "appdata\\", "system32\\", "syswow64\\",
        "startup\\", "autostart"
    };
    
    const std::vector<std::string> IP_PATTERNS = {
        // Look for IP address patterns (simplified check)
        "192.168.", "10.0.", "172.16.", "127.0.0.1"
    };
    
    // Convert file data to string for pattern matching
    std::string fileContent((char*)pFileInfo->hFileContent, 
                           std::min(pFileInfo->dwFileSize, (DWORD)1048576)); // Limit to 1MB for performance
    
    // Convert to lowercase for case-insensitive matching
    std::transform(fileContent.begin(), fileContent.end(), fileContent.begin(), ::tolower);
    
    int suspiciousStringCount = 0;
    
    // Check for suspicious strings
    for (const auto& suspiciousString : SUSPICIOUS_STRINGS) {
        std::string lowerString = suspiciousString;
        std::transform(lowerString.begin(), lowerString.end(), lowerString.begin(), ::tolower);
        
        if (fileContent.find(lowerString) != std::string::npos) {
            suspiciousStringCount++;
            if (suspiciousStringCount >= 3) { // Threshold for suspicious
                return true;
            }
        }
    }
    
    // Check for IP address patterns
    for (const auto& ipPattern : IP_PATTERNS) {
        if (fileContent.find(ipPattern) != std::string::npos) {
            suspiciousStringCount++;
            if (suspiciousStringCount >= 3) {
                return true;
            }
        }
    }
    
    // Look for base64-like patterns (potential encoded payloads)
    size_t base64Count = 0;
    size_t consecutiveBase64 = 0;
    
    for (char c : fileContent) {
        if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || 
            (c >= '0' && c <= '9') || c == '+' || c == '/' || c == '=') {
            consecutiveBase64++;
            if (consecutiveBase64 > 100) { // Long base64-like sequences
                base64Count++;
                consecutiveBase64 = 0;
                if (base64Count >= 3) {
                    return true; // Multiple long base64-like sequences are suspicious
                }
            }
        } else {
            consecutiveBase64 = 0;
        }
    }
    
    return false; // No significant suspicious patterns found
}

// Helper function to calculate entropy
double PEMalwareAnalysisEngine::calculateSectionEntropy(const BYTE* data, size_t size) {
    if (!data || size == 0) return 0.0;
    
    unsigned int frequency[256] = {0};
    for (size_t i = 0; i < size; i++) {
        frequency[data[i]]++;
    }
    
    double entropy = 0.0;
    for (int i = 0; i < 256; i++) {
        if (frequency[i] > 0) {
            double probability = (double)frequency[i] / size;
            entropy -= probability * log2(probability);
        }
    }
    
    return entropy;
}

int PEMalwareAnalysisEngine::calculateRiskScore(const std::vector<MalwareIndicator>& indicators) {
    int score = 0;
    for (const auto& indicator : indicators) {
        if (indicator.isDetected) {
            if (indicator.category == "Packer Detection") {
                score += PACKER_WEIGHT;
            } else if (indicator.category == "Anti-Analysis") {
                score += ANTI_ANALYSIS_WEIGHT;
            } else if (indicator.category == "Suspicious Imports") {
                score += SUSPICIOUS_IMPORTS_WEIGHT;
            } else if (indicator.category == "Suspicious Sections") {
                score += SUSPICIOUS_SECTIONS_WEIGHT;
            } else if (indicator.category == "Obfuscation") {
                score += OBFUSCATION_WEIGHT;
            }
        }
    }
    return std::min(score, 100); 
}

std::string PEMalwareAnalysisEngine::classifyMalware(const MalwareAnalysisResult& result) {
    if (result.riskScore <= 10) {
        return "Clean/Low Risk";
    } else if (result.riskScore <= 40) {
        return "Suspicious";
    } else if (result.riskScore <= 70) {
        return "Likely Malware";
    } else {
        return "High Risk Malware";
    }
}

std::string PEMalwareAnalysisEngine::generateRecommendation(int riskScore, const std::string& classification) {
    (void)classification; // Suppress unused parameter warning
    
    if (riskScore <= 10) {
        return "File appears clean. Standard security practices apply.";
    } else if (riskScore <= 40) {
        return "Exercise caution. Consider additional analysis with behavioral tools.";
    } else if (riskScore <= 70) {
        return "High risk file. Recommend sandboxed analysis and avoid execution.";
    } else {
        return "DANGEROUS: Do not execute. Quarantine and analyze in isolated environment.";
    }
}

void PEMalwareAnalysisEngine::logMalwareAnalysis(const MalwareAnalysisResult& analysisResult) {
    LOGF("\tRisk Score: %d/100\n", analysisResult.riskScore);
    LOGF("\tClassification: %s\n", analysisResult.classification.c_str());
    LOGF("\tSuspicious: %s\n", analysisResult.isSuspicious ? "YES" : "NO");
    
    if (!analysisResult.indicators.empty()) {
        LOGF("\tThreat Indicators (%zu found):\n", analysisResult.indicators.size());
        for (const auto& indicator : analysisResult.indicators) {
            if (indicator.isDetected) {
                LOGF("\t\t[%s] %s (Severity: %d/10)\n", 
                     indicator.category.c_str(),
                     indicator.description.c_str(),
                     indicator.severity);
                if (!indicator.evidence.empty()) {
                    LOGF("\t\t    Evidence: %s\n", indicator.evidence.c_str());
                }
            }
        }
    } else {
        LOGF("\tThreat Indicators: None detected\n");
    }
    
    LOGF("\tRecommendation: %s\n", analysisResult.recommendation.c_str());
}

bool PEMalwareAnalysisEngine::hasHighSeverityIndicators(const std::vector<MalwareIndicator>& indicators) {
    for (const auto& indicator : indicators) {
        if (indicator.severity >= 8) {
            return true;
        }
    }
    return false;
}

// Placeholder functions for API pattern detection
std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectEntropyAnomalies(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;
    
    if (!pFileInfo || !pFileInfo->pNtHeader) {
        return indicators;
    }
    
    PIMAGE_SECTION_HEADER pSectionHeader;
    int numberOfSections;
    
    if (pFileInfo->bIs64Bit) {
        auto pNtHeader64 = (PIMAGE_NT_HEADERS64)pFileInfo->pNtHeader;
        numberOfSections = pNtHeader64->FileHeader.NumberOfSections;
        pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)pNtHeader64 + 4 + sizeof(IMAGE_FILE_HEADER) + pNtHeader64->FileHeader.SizeOfOptionalHeader);
    } else {
        auto pNtHeader32 = (PIMAGE_NT_HEADERS32)pFileInfo->pNtHeader;
        numberOfSections = pNtHeader32->FileHeader.NumberOfSections;
        pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)pNtHeader32 + 4 + sizeof(IMAGE_FILE_HEADER) + pNtHeader32->FileHeader.SizeOfOptionalHeader);
    }
    
    std::vector<double> sectionEntropies;
    std::vector<std::string> sectionNames;
    
    // Calculate entropy for each section
    for (int i = 0; i < numberOfSections; i++) {
        std::string sectionName(reinterpret_cast<const char*>(pSectionHeader[i].Name), 8);
        sectionName = sectionName.substr(0, sectionName.find('\0')); // Remove null padding
        sectionNames.push_back(sectionName);
        
        // Simple entropy calculation (simplified version)
        const uint8_t* sectionData = reinterpret_cast<const uint8_t*>(pFileInfo->pDosHeader) + pSectionHeader[i].PointerToRawData;
        size_t sectionSize = pSectionHeader[i].SizeOfRawData;
        
        if (sectionSize == 0) {
            sectionEntropies.push_back(0.0);
            continue;
        }
        
        // Calculate byte frequency
        std::vector<int> frequency(256, 0);
        for (size_t j = 0; j < sectionSize && j < 65536; j++) { // Limit to 64KB for performance
            frequency[sectionData[j]]++;
        }
        
        // Calculate entropy
        double entropy = 0.0;
        size_t totalBytes = std::min(sectionSize, static_cast<size_t>(65536));
        for (int freq : frequency) {
            if (freq > 0) {
                double probability = static_cast<double>(freq) / totalBytes;
                entropy -= probability * log2(probability);
            }
        }
        
        sectionEntropies.push_back(entropy);
    }
    
    // Analyze entropy patterns
    if (!sectionEntropies.empty()) {
        // Check for very high entropy sections (possible packing/encryption)
        for (size_t i = 0; i < sectionEntropies.size(); i++) {
            if (sectionEntropies[i] > 7.5) {
                MalwareIndicator indicator;
                indicator.category = "High Entropy Section";
                indicator.description = "Section has very high entropy suggesting encryption or packing";
                indicator.evidence = "Section '" + sectionNames[i] + "' has entropy " + std::to_string(sectionEntropies[i]);
                indicator.severity = 7;
                indicators.push_back(indicator);
            }
        }
        
        // Check for entropy variance (mixed packed/unpacked content)
        double minEntropy = *std::min_element(sectionEntropies.begin(), sectionEntropies.end());
        double maxEntropy = *std::max_element(sectionEntropies.begin(), sectionEntropies.end());
        double entropyVariance = maxEntropy - minEntropy;
        
        if (entropyVariance > 4.0 && maxEntropy > 6.0) {
            MalwareIndicator indicator;
            indicator.category = "Entropy Variance";
            indicator.description = "Large entropy variance between sections";
            indicator.evidence = "Entropy range: " + std::to_string(minEntropy) + " - " + std::to_string(maxEntropy);
            indicator.severity = 6;
            indicators.push_back(indicator);
        }
        
        // Check for executable sections with high entropy
        for (int i = 0; i < numberOfSections; i++) {
            if ((pSectionHeader[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) && sectionEntropies[i] > 6.5) {
                MalwareIndicator indicator;
                indicator.category = "High Entropy Executable";
                indicator.description = "Executable section has suspiciously high entropy";
                indicator.evidence = "Executable section '" + sectionNames[i] + "' entropy: " + std::to_string(sectionEntropies[i]);
                indicator.severity = 8;
                indicators.push_back(indicator);
            }
        }
    }
    
    return indicators;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectTimestampManipulation(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;
    
    if (!pFileInfo || !pFileInfo->pNtHeader) {
        return indicators;
    }
    
    DWORD timestamp;
    if (pFileInfo->bIs64Bit) {
        auto pNtHeader64 = (PIMAGE_NT_HEADERS64)pFileInfo->pNtHeader;
        timestamp = pNtHeader64->FileHeader.TimeDateStamp;
    } else {
        auto pNtHeader32 = (PIMAGE_NT_HEADERS32)pFileInfo->pNtHeader;
        timestamp = pNtHeader32->FileHeader.TimeDateStamp;
    }
    
    // Known malware timestamps (WannaCry, etc.)
    const std::vector<DWORD> KNOWN_MALWARE_TIMESTAMPS = {
        0x4D4E196B, // WannaCry: Nov 20, 2010 09:05:15 UTC
        0x2A425E19, // Stuxnet timestamp
        0x00000000, // NULL timestamp (suspicious)
        0xFFFFFFFF  // Maximum timestamp (suspicious)
    };
    
    // Check for known malware timestamps
    for (DWORD malwareTimestamp : KNOWN_MALWARE_TIMESTAMPS) {
        if (timestamp == malwareTimestamp) {
            MalwareIndicator indicator;
            indicator.category = "Known Malware Timestamp";
            indicator.severity = (timestamp == 0x4D4E196B) ? 9 : 8; // WannaCry gets highest severity
            indicator.description = "Timestamp matches known malware signature";
            
            std::stringstream evidenceStream;
            evidenceStream << "Timestamp: 0x" << std::hex << timestamp;
            if (timestamp == 0x4D4E196B) {
                evidenceStream << " (WannaCry signature timestamp)";
            }
            indicator.evidence = evidenceStream.str();
            
            indicators.push_back(indicator);
            break;
        }
    }
    
    // Check for anachronistic timestamps (before PE format existed)
    time_t pe_epoch = 631152000; // January 1, 1990 (PE format introduced)
    if (timestamp != 0 && timestamp < pe_epoch) {
        MalwareIndicator indicator;
        indicator.category = "Anachronistic Timestamp";
        indicator.severity = 7;
        indicator.description = "Timestamp predates PE format existence";
        
        std::stringstream evidenceStream;
        evidenceStream << "Timestamp: 0x" << std::hex << timestamp << " (before 1990)";
        indicator.evidence = evidenceStream.str();
        
        indicators.push_back(indicator);
    }
    
    // Check for future timestamps (compiled in the future)
    time_t current_time = time(nullptr);
    if (timestamp > current_time + 86400) { // Allow 24 hours for clock differences
        MalwareIndicator indicator;
        indicator.category = "Future Timestamp";
        indicator.severity = 6;
        indicator.description = "Compilation timestamp is in the future";
        
        std::stringstream evidenceStream;
        evidenceStream << "Timestamp: 0x" << std::hex << timestamp << " (future date)";
        indicator.evidence = evidenceStream.str();
        
        indicators.push_back(indicator);
    }
    
    return indicators;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectOverlayAnomalies(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;
    
    if (!pFileInfo || !pFileInfo->pNtHeader || !pFileInfo->hFileContent) {
        return indicators;
    }
    
    // Calculate the end of the last section
    PIMAGE_SECTION_HEADER sectionHeader;
    int numberOfSections;
    
    if (pFileInfo->bIs64Bit) {
        auto pNtHeader64 = (PIMAGE_NT_HEADERS64)pFileInfo->pNtHeader;
        numberOfSections = pNtHeader64->FileHeader.NumberOfSections;
        sectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)pNtHeader64 + 4 + sizeof(IMAGE_FILE_HEADER) + pNtHeader64->FileHeader.SizeOfOptionalHeader);
    } else {
        auto pNtHeader32 = (PIMAGE_NT_HEADERS32)pFileInfo->pNtHeader;
        numberOfSections = pNtHeader32->FileHeader.NumberOfSections;
        sectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)pNtHeader32 + 4 + sizeof(IMAGE_FILE_HEADER) + pNtHeader32->FileHeader.SizeOfOptionalHeader);
    }
    
    // Find the end of the last section
    DWORD lastSectionEnd = 0;
    for (int i = 0; i < numberOfSections; i++) {
        DWORD sectionEnd = sectionHeader[i].PointerToRawData + sectionHeader[i].SizeOfRawData;
        if (sectionEnd > lastSectionEnd) {
            lastSectionEnd = sectionEnd;
        }
    }
    
    // Check if there's data after the last section (overlay)
    if (lastSectionEnd < pFileInfo->dwFileSize) {
        size_t overlaySize = pFileInfo->dwFileSize - lastSectionEnd;
        
        // Large overlays are suspicious
        if (overlaySize > 1024) { // More than 1KB overlay
            MalwareIndicator indicator;
            indicator.category = "Large Overlay Data";
            indicator.severity = (overlaySize > 100000) ? 8 : 6; // Very large overlays are more suspicious
            indicator.description = "File contains significant data after last PE section";
            
            std::stringstream evidenceStream;
            evidenceStream << "Overlay size: " << overlaySize << " bytes starting at offset 0x" 
                          << std::hex << lastSectionEnd;
            indicator.evidence = evidenceStream.str();
            
            indicators.push_back(indicator);
        }
        
        // Analyze overlay content for suspicious patterns
        const BYTE* overlayData = (const BYTE*)pFileInfo->hFileContent + lastSectionEnd;
        
        // Check for high entropy in overlay (possible encryption/compression)
        double overlayEntropy = calculateSectionEntropy(overlayData, std::min(overlaySize, (size_t)4096));
        if (overlayEntropy > 7.5) {
            MalwareIndicator indicator;
            indicator.category = "High Entropy Overlay";
            indicator.severity = 7;
            indicator.description = "Overlay contains high-entropy data (possible encryption)";
            
            std::stringstream evidenceStream;
            evidenceStream << "Overlay entropy: " << std::fixed << std::setprecision(2) << overlayEntropy;
            indicator.evidence = evidenceStream.str();
            
            indicators.push_back(indicator);
        }
        
        // Check for embedded PE signatures in overlay
        for (size_t i = 0; i < overlaySize - 4 && i < 4096; i++) {
            if (overlayData[i] == 'M' && overlayData[i+1] == 'Z') {
                MalwareIndicator indicator;
                indicator.category = "Embedded PE in Overlay";
                indicator.severity = 8;
                indicator.description = "Overlay contains embedded PE file signature";
                
                std::stringstream evidenceStream;
                evidenceStream << "PE signature found at overlay offset 0x" << std::hex << i;
                indicator.evidence = evidenceStream.str();
                
                indicators.push_back(indicator);
                break; // Only report first occurrence
            }
        }
    }
    
    return indicators;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectAPIPatterns(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;
    
    if (!pFileInfo) {
        return indicators;
    }
    
    // Define suspicious API patterns commonly used by malware
    const std::vector<std::string> ANTI_DEBUG_APIS = {
        "IsDebuggerPresent", "CheckRemoteDebuggerPresent", "NtQueryInformationProcess",
        "OutputDebugStringA", "OutputDebugStringW", "GetTickCount", "QueryPerformanceCounter"
    };
    
    const std::vector<std::string> PROCESS_MANIPULATION_APIS = {
        "CreateProcess", "CreateRemoteThread", "WriteProcessMemory", "ReadProcessMemory",
        "VirtualAllocEx", "VirtualProtectEx", "SetWindowsHookEx", "EnumProcesses"
    };
    
    const std::vector<std::string> NETWORK_APIS = {
        "InternetOpen", "InternetConnect", "HttpOpenRequest", "WinHttpOpen",
        "socket", "connect", "send", "recv", "WSAStartup"
    };
    
    const std::vector<std::string> CRYPTO_APIS = {
        "CryptAcquireContext", "CryptCreateHash", "CryptHashData", "CryptEncrypt",
        "CryptDecrypt", "CryptGenKey", "CryptExportKey", "CryptImportKey"
    };
    
    const std::vector<std::string> PERSISTENCE_APIS = {
        "RegOpenKey", "RegSetValue", "RegCreateKey", "CreateService",
        "OpenSCManager", "StartService", "CreateFile", "WriteFile"
    };
    
    // This is a simplified implementation - in a real system, you would
    // parse the import table and check each imported function
    // For now, we'll use a heuristic based on the import table corruption
    // we already detect
    
    extern int g_CorruptedImports;
    extern int g_InvalidDLLNames;
    
    // If we have corrupted imports, it might indicate API obfuscation
    if (g_CorruptedImports > 0) {
        MalwareIndicator indicator;
        indicator.category = "API Obfuscation";
        indicator.description = "Import table corruption detected - possible API hiding";
        indicator.evidence = "Corrupted import entries: " + std::to_string(g_CorruptedImports);
        indicator.severity = 7;
        indicators.push_back(indicator);
    }
    
    // Check for invalid DLL names which might indicate dynamic loading obfuscation
    if (g_InvalidDLLNames > 3) {
        MalwareIndicator indicator;
        indicator.category = "Dynamic Loading";
        indicator.description = "Multiple invalid DLL names suggest dynamic API resolution";
        indicator.evidence = "Invalid DLL names: " + std::to_string(g_InvalidDLLNames);
        indicator.severity = 6;
        indicators.push_back(indicator);
    }
    
    return indicators;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectStructuralAnomalies(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;
    
    if (!pFileInfo || !pFileInfo->pDosHeader || !pFileInfo->pNtHeader) {
        return indicators;
    }
    
    // Check DOS header magic
    if (pFileInfo->pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
        MalwareIndicator indicator;
        indicator.category = "Invalid DOS Signature";
        indicator.severity = 9;
        indicator.description = "DOS header has invalid magic signature";
        
        std::stringstream evidenceStream;
        evidenceStream << "Expected: 0x" << std::hex << IMAGE_DOS_SIGNATURE 
                      << ", Found: 0x" << std::hex << pFileInfo->pDosHeader->e_magic;
        indicator.evidence = evidenceStream.str();
        
        indicators.push_back(indicator);
    }
    
    // Check NT header signature
    DWORD ntSignature;
    if (pFileInfo->bIs64Bit) {
        auto pNtHeader64 = (PIMAGE_NT_HEADERS64)pFileInfo->pNtHeader;
        ntSignature = pNtHeader64->Signature;
    } else {
        auto pNtHeader32 = (PIMAGE_NT_HEADERS32)pFileInfo->pNtHeader;
        ntSignature = pNtHeader32->Signature;
    }
    
    if (ntSignature != IMAGE_NT_SIGNATURE) {
        MalwareIndicator indicator;
        indicator.category = "Invalid PE Signature";
        indicator.severity = 9;
        indicator.description = "PE header has invalid signature";
        
        std::stringstream evidenceStream;
        evidenceStream << "Expected: 0x" << std::hex << IMAGE_NT_SIGNATURE 
                      << ", Found: 0x" << std::hex << ntSignature;
        indicator.evidence = evidenceStream.str();
        
        indicators.push_back(indicator);
    }
    
    // Check e_lfanew points to valid location
    DWORD e_lfanew = pFileInfo->pDosHeader->e_lfanew;
    if (e_lfanew > pFileInfo->dwFileSize - sizeof(IMAGE_NT_HEADERS32)) {
        MalwareIndicator indicator;
        indicator.category = "Invalid e_lfanew Offset";
        indicator.severity = 8;
        indicator.description = "DOS header e_lfanew points beyond file bounds";
        
        std::stringstream evidenceStream;
        evidenceStream << "e_lfanew: 0x" << std::hex << e_lfanew 
                      << ", File size: 0x" << std::hex << pFileInfo->dwFileSize;
        indicator.evidence = evidenceStream.str();
        
        indicators.push_back(indicator);
    }
    
    // Check for suspicious number of sections
    int numberOfSections;
    if (pFileInfo->bIs64Bit) {
        auto pNtHeader64 = (PIMAGE_NT_HEADERS64)pFileInfo->pNtHeader;
        numberOfSections = pNtHeader64->FileHeader.NumberOfSections;
    } else {
        auto pNtHeader32 = (PIMAGE_NT_HEADERS32)pFileInfo->pNtHeader;
        numberOfSections = pNtHeader32->FileHeader.NumberOfSections;
    }
    
    if (numberOfSections == 0) {
        MalwareIndicator indicator;
        indicator.category = "No PE Sections";
        indicator.severity = 9;
        indicator.description = "PE file has no sections defined";
        indicator.evidence = "NumberOfSections: 0";
        indicators.push_back(indicator);
    } else if (numberOfSections > 96) { // Theoretical maximum is 96
        MalwareIndicator indicator;
        indicator.category = "Excessive Section Count";
        indicator.severity = 7;
        indicator.description = "PE file has unusually high number of sections";
        
        std::stringstream evidenceStream;
        evidenceStream << "NumberOfSections: " << numberOfSections << " (>96 is unusual)";
        indicator.evidence = evidenceStream.str();
        
        indicators.push_back(indicator);
    }
    
    // Check AddressOfEntryPoint validity
    DWORD entryPoint;
    if (pFileInfo->bIs64Bit) {
        auto pNtHeader64 = (PIMAGE_NT_HEADERS64)pFileInfo->pNtHeader;
        entryPoint = pNtHeader64->OptionalHeader.AddressOfEntryPoint;
    } else {
        auto pNtHeader32 = (PIMAGE_NT_HEADERS32)pFileInfo->pNtHeader;
        entryPoint = pNtHeader32->OptionalHeader.AddressOfEntryPoint;
    }
    
    if (entryPoint == 0) {
        MalwareIndicator indicator;
        indicator.category = "Zero Entry Point";
        indicator.severity = 6;
        indicator.description = "Entry point address is zero (DLL or malformed)";
        indicator.evidence = "AddressOfEntryPoint: 0x00000000";
        indicators.push_back(indicator);
    }
    
    return indicators;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectStringAnomalies(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;
    
    if (!pFileInfo || !pFileInfo->pDosHeader) {
        return indicators;
    }
    
    // Define suspicious string patterns commonly found in malware
    const std::vector<std::string> SUSPICIOUS_STRINGS = {
        "payload", "exploit", "shell", "backdoor", "trojan", "virus",
        "keylog", "stealer", "botnet", "rootkit", "ransomware", "miner",
        "debug.exe", "taskkill", "net user", "reg add", "schtasks",
        "powershell", "cmd.exe", "rundll32", "regsvr32", "certutil"
    };
    
    const std::vector<std::string> OBFUSCATION_PATTERNS = {
        "aaaaaaa", "1111111", "xxxxxxx", "0000000",
        "base64", "decode", "encode", "decrypt", "unpack"
    };
    
    // Search for strings in the file (simplified approach)
    const char* fileData = reinterpret_cast<const char*>(pFileInfo->pDosHeader);
    size_t fileSize = 0; // We don't have file size readily available, estimate from sections
    
    // Calculate approximate file size from sections
    if (pFileInfo->pNtHeader) {
        PIMAGE_SECTION_HEADER pSectionHeader;
        int numberOfSections;
        
        if (pFileInfo->bIs64Bit) {
            auto pNtHeader64 = (PIMAGE_NT_HEADERS64)pFileInfo->pNtHeader;
            numberOfSections = pNtHeader64->FileHeader.NumberOfSections;
            pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)pNtHeader64 + 4 + sizeof(IMAGE_FILE_HEADER) + pNtHeader64->FileHeader.SizeOfOptionalHeader);
        } else {
            auto pNtHeader32 = (PIMAGE_NT_HEADERS32)pFileInfo->pNtHeader;
            numberOfSections = pNtHeader32->FileHeader.NumberOfSections;
            pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)pNtHeader32 + 4 + sizeof(IMAGE_FILE_HEADER) + pNtHeader32->FileHeader.SizeOfOptionalHeader);
        }
        
        // Find the last section to estimate file size
        for (int i = 0; i < numberOfSections; i++) {
            size_t sectionEnd = pSectionHeader[i].PointerToRawData + pSectionHeader[i].SizeOfRawData;
            if (sectionEnd > fileSize) {
                fileSize = sectionEnd;
            }
        }
    }
    
    // Limit scanning to reasonable size (first 1MB)
    if (fileSize > 1024 * 1024) {
        fileSize = 1024 * 1024;
    }
    
    int suspiciousStringCount = 0;
    int obfuscationStringCount = 0;
    
    // Simple string scanning (looking for printable sequences)
    std::string currentString;
    for (size_t i = 0; i < fileSize; i++) {
        char c = fileData[i];
        if (c >= 32 && c <= 126) { // Printable ASCII
            currentString += c;
        } else {
            if (currentString.length() >= 4) {
                // Convert to lowercase for comparison
                std::string lowerStr = currentString;
                std::transform(lowerStr.begin(), lowerStr.end(), lowerStr.begin(), ::tolower);
                
                // Check for suspicious strings
                for (const auto& suspiciousStr : SUSPICIOUS_STRINGS) {
                    if (lowerStr.find(suspiciousStr) != std::string::npos) {
                        suspiciousStringCount++;
                        break;
                    }
                }
                
                // Check for obfuscation patterns
                for (const auto& obfPattern : OBFUSCATION_PATTERNS) {
                    if (lowerStr.find(obfPattern) != std::string::npos) {
                        obfuscationStringCount++;
                        break;
                    }
                }
            }
            currentString.clear();
        }
    }
    
    // Create indicators based on findings
    if (suspiciousStringCount > 2) {
        MalwareIndicator indicator;
        indicator.category = "Suspicious Strings";
        indicator.description = "Multiple suspicious strings found in file";
        indicator.evidence = "Found " + std::to_string(suspiciousStringCount) + " suspicious string patterns";
        indicator.severity = (suspiciousStringCount > 5) ? 8 : 6;
        indicators.push_back(indicator);
    }
    
    if (obfuscationStringCount > 1) {
        MalwareIndicator indicator;
        indicator.category = "String Obfuscation";
        indicator.description = "Possible string obfuscation patterns detected";
        indicator.evidence = "Found " + std::to_string(obfuscationStringCount) + " obfuscation indicators";
        indicator.severity = 7;
        indicators.push_back(indicator);
    }
    
    return indicators;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectSectionAnomalies(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;
    
    if (!pFileInfo || !pFileInfo->pNtHeader) {
        return indicators;
    }
    
    PIMAGE_SECTION_HEADER sectionHeader;
    int numberOfSections;
    
    if (pFileInfo->bIs64Bit) {
        auto pNtHeader64 = (PIMAGE_NT_HEADERS64)pFileInfo->pNtHeader;
        numberOfSections = pNtHeader64->FileHeader.NumberOfSections;
        sectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)pNtHeader64 + 4 + sizeof(IMAGE_FILE_HEADER) + pNtHeader64->FileHeader.SizeOfOptionalHeader);
    } else {
        auto pNtHeader32 = (PIMAGE_NT_HEADERS32)pFileInfo->pNtHeader;
        numberOfSections = pNtHeader32->FileHeader.NumberOfSections;
        sectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)pNtHeader32 + 4 + sizeof(IMAGE_FILE_HEADER) + pNtHeader32->FileHeader.SizeOfOptionalHeader);
    }
    
    for (int i = 0; i < numberOfSections; i++) {
        // Check for RWX sections (Read, Write, Execute)
        DWORD characteristics = sectionHeader[i].Characteristics;
        bool isReadable = (characteristics & IMAGE_SCN_MEM_READ) != 0;
        bool isWritable = (characteristics & IMAGE_SCN_MEM_WRITE) != 0;
        bool isExecutable = (characteristics & IMAGE_SCN_MEM_EXECUTE) != 0;
        
        if (isReadable && isWritable && isExecutable) {
            MalwareIndicator indicator;
            indicator.category = "RWX Section Detected";
            indicator.severity = 8;
            indicator.description = "Section has Read, Write, and Execute permissions";
            
            std::stringstream evidenceStream;
            evidenceStream << "Section: " << std::string((char*)sectionHeader[i].Name, 8) 
                          << ", Characteristics: 0x" << std::hex << characteristics;
            indicator.evidence = evidenceStream.str();
            
            indicators.push_back(indicator);
        }
        
        // Check for unusual section names
        std::string sectionName((char*)sectionHeader[i].Name, 8);
        sectionName = sectionName.substr(0, sectionName.find('\0')); // Remove null padding
        
        // Known packer section names
        const std::vector<std::string> PACKER_SECTIONS = {
            "UPX0", "UPX1", "UPX2", ".aspack", ".adata", ".ASPack",
            ".ccg", ".boom", ".fake", ".nsp0", ".nsp1", ".nsp2",
            "MEW", ".MPRESS1", ".MPRESS2", ".vmp0", ".vmp1", ".vmp2"
        };
        
        for (const auto& packerSection : PACKER_SECTIONS) {
            if (sectionName.find(packerSection) != std::string::npos) {
                MalwareIndicator indicator;
                indicator.category = "Packer Section Name";
                indicator.severity = 7;
                indicator.description = "Section name indicates packer usage";
                
                std::stringstream evidenceStream;
                evidenceStream << "Section: " << sectionName << " (matches " << packerSection << ")";
                indicator.evidence = evidenceStream.str();
                
                indicators.push_back(indicator);
                break;
            }
        }
        
        // Check for sections with zero virtual size but non-zero raw size
        if (sectionHeader[i].Misc.VirtualSize == 0 && sectionHeader[i].SizeOfRawData > 0) {
            MalwareIndicator indicator;
            indicator.category = "Zero Virtual Size Section";
            indicator.severity = 6;
            indicator.description = "Section has zero virtual size but contains raw data";
            
            std::stringstream evidenceStream;
            evidenceStream << "Section: " << sectionName 
                          << ", Virtual Size: 0, Raw Size: " << sectionHeader[i].SizeOfRawData;
            indicator.evidence = evidenceStream.str();
            
            indicators.push_back(indicator);
        }
        
        // Check for extremely large sections
        if (sectionHeader[i].SizeOfRawData > 50 * 1024 * 1024) { // 50MB
            MalwareIndicator indicator;
            indicator.category = "Extremely Large Section";
            indicator.severity = 5;
            indicator.description = "Section size is unusually large";
            
            std::stringstream evidenceStream;
            evidenceStream << "Section: " << sectionName 
                          << ", Size: " << (sectionHeader[i].SizeOfRawData / (1024*1024)) << " MB";
            indicator.evidence = evidenceStream.str();
            
            indicators.push_back(indicator);
        }
        
        // Check section alignment anomalies
        if (sectionHeader[i].PointerToRawData % 512 != 0 && sectionHeader[i].PointerToRawData != 0) {
            MalwareIndicator indicator;
            indicator.category = "Poor Section Alignment";
            indicator.severity = 4;
            indicator.description = "Section not aligned to file sector boundary";
            
            std::stringstream evidenceStream;
            evidenceStream << "Section: " << sectionName 
                          << ", Raw Offset: 0x" << std::hex << sectionHeader[i].PointerToRawData;
            indicator.evidence = evidenceStream.str();
            
            indicators.push_back(indicator);
        }
    }
    
    return indicators;
}

std::string PEMalwareAnalysisEngine::generateDetailedReport(const MalwareAnalysisResult& result) {
    std::stringstream report;
    
    report << "\n=== DETAILED MALWARE ANALYSIS REPORT ===\n";
    std::time_t now = std::time(nullptr);
    report << "Analysis Date: " << std::ctime(&now);
    report << "Risk Score: " << result.riskScore << "/100\n";
    report << "Classification: " << result.classification << "\n";
    report << "Suspicious: " << (result.isSuspicious ? "YES" : "NO") << "\n\n";
    
    if (!result.indicators.empty()) {
        report << "THREAT INDICATORS FOUND (" << result.indicators.size() << "):\n";
        report << "========================================\n";
        
        for (size_t i = 0; i < result.indicators.size(); i++) {
            const auto& indicator = result.indicators[i];
            
            report << "[" << (i + 1) << "] " << indicator.category << "\n";
            report << "    Severity: " << indicator.severity << "/10\n";
            report << "    Description: " << indicator.description << "\n";
            report << "    Evidence: " << indicator.evidence << "\n";
            
            // Add risk assessment
            if (indicator.severity >= 8) {
                report << "    Risk Level: HIGH\n";
            } else if (indicator.severity >= 6) {
                report << "    Risk Level: MEDIUM\n";
            } else {
                report << "    Risk Level: LOW\n";
            }
            report << "\n";
        }
    } else {
        report << "NO THREAT INDICATORS DETECTED\n";
        report << "This file appears to be clean based on current analysis.\n\n";
    }
    
    // Add recommendations
    report << "RECOMMENDATIONS:\n";
    report << "================\n";
    
    if (result.riskScore >= 70) {
        report << "🚨 HIGH RISK - This file is likely malicious\n";
        report << "   • DO NOT EXECUTE this file\n";
        report << "   • Isolate the file immediately\n";
        report << "   • Submit to antivirus vendors for analysis\n";
        report << "   • Consider forensic analysis\n";
    } else if (result.riskScore >= 40) {
        report << "⚠️  MEDIUM RISK - This file shows suspicious characteristics\n";
        report << "   • Exercise extreme caution\n";
        report << "   • Execute only in isolated environment\n";
        report << "   • Monitor system behavior if executed\n";
        report << "   • Scan with multiple antivirus engines\n";
    } else {
        report << "✅ LOW RISK - This file appears relatively safe\n";
        report << "   • File shows minimal suspicious indicators\n";
        report << "   • Standard security precautions recommended\n";
        report << "   • Regular antivirus scanning advised\n";
    }
    
    report << "\n";
    report << "TECHNICAL ANALYSIS SUMMARY:\n";
    report << "===========================\n";
    
    // Count indicators by type
    std::map<std::string, int> indicatorTypes;
    for (const auto& indicator : result.indicators) {
        indicatorTypes[indicator.category]++;
    }
    
    if (!indicatorTypes.empty()) {
        report << "Indicators by Category:\n";
        for (const auto& pair : indicatorTypes) {
            report << "  • " << pair.first << ": " << pair.second << " finding(s)\n";
        }
    }
    
    report << "\nAnalysis Confidence: ";
    if (result.indicators.size() >= 3) {
        report << "HIGH (Multiple indicators detected)\n";
    } else if (result.indicators.size() >= 1) {
        report << "MEDIUM (Some indicators detected)\n";
    } else {
        report << "LOW (Limited indicators available)\n";
    }
    
    report << "\nNote: This analysis is based on static file analysis.\n";
    report << "Dynamic analysis in a sandbox environment is recommended\n";
    report << "for comprehensive threat assessment.\n";
    
    report << "\n=== END OF DETAILED REPORT ===\n";
    
    return report.str();
}

std::string PEMalwareAnalysisEngine::generateSummaryReport(const MalwareAnalysisResult& result) {
    (void)result;
    return "Summary report not implemented";
}

bool PEMalwareAnalysisEngine::isKnownPacker(const std::string& sectionName) {
    for (const auto& packer : KNOWN_PACKERS) {
        if (sectionName.find(packer) != std::string::npos) {
            return true;
        }
    }
    return false;
}
