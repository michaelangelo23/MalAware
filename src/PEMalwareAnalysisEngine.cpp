#include "../include/PEMalwareAnalysisEngine.h"
#include "../include/peSectionParser.h"
#include "../include/peImportExport.h"
#include <algorithm>
#include <sstream>
#include <iomanip>
#include <cctype>
#include <cmath>
#include <ctime>
#include <chrono>


DWORD RvaToFileOffset_Helper(DWORD rva, PPE_FILE_INFO pFileInfo) {
    if (!pFileInfo || !pFileInfo->ntHeader) {
        throw std::runtime_error("Invalid PE file info");
    }

    PIMAGE_SECTION_HEADER sectionHeader;
    int numberOfSections;

    if (pFileInfo->is64Bit) {
        auto pNtHeader64 = (PIMAGE_NT_HEADERS64)pFileInfo->ntHeader;
        numberOfSections = pNtHeader64->FileHeader.NumberOfSections;
        sectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)pNtHeader64 + 4 + sizeof(IMAGE_FILE_HEADER) + pNtHeader64->FileHeader.SizeOfOptionalHeader);
    } else {
        auto pNtHeader32 = (PIMAGE_NT_HEADERS32)pFileInfo->ntHeader;
        numberOfSections = pNtHeader32->FileHeader.NumberOfSections;
        sectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)pNtHeader32 + 4 + sizeof(IMAGE_FILE_HEADER) + pNtHeader32->FileHeader.SizeOfOptionalHeader);
    }


    for (int i = 0; i < numberOfSections; i++) {
        DWORD sectionStart = sectionHeader[i].VirtualAddress;
        DWORD sectionEnd = sectionStart + sectionHeader[i].Misc.VirtualSize;

        if (rva >= sectionStart && rva < sectionEnd) {
            return rva - sectionStart + sectionHeader[i].PointerToRawData;
        }
    }


    if (rva < 0x1000) {
        return rva;
    }

    throw std::runtime_error("RVA not found in any section");
}


const std::vector<std::string> PEMalwareAnalysisEngine::KNOWN_PACKERS = {
    "UPX", "ASPack", "PECompact", "NSPack", "Themida", "VMProtect", "Armadillo",
    ".aspack", ".upx", ".nsp", ".themida", ".vmp", ".arm", ".petite", ".yoda",
    "PEPACK", "PACKWIN", "ASPR", "Enigma", "ExeCryptor", "FSG", "MEW", "Molebox"
};

const std::vector<std::string> PEMalwareAnalysisEngine::ANTI_DEBUG_IMPORTS = {
    "IsDebuggerPresent", "CheckRemoteDebuggerPresent", "OutputDebugStringA",
    "OutputDebugStringW", "GetTickCount", "QueryPerformanceCounter", "timeGetTime",
    "NtQueryInformationProcess", "NtSetInformationThread", "NtQuerySystemInformation"
};

const std::vector<std::string> PEMalwareAnalysisEngine::ANTI_VM_IMPORTS = {
    "CreateFileA", "CreateFileW", "FindWindowA", "FindWindowW", "GetSystemInfo",
    "GetVersionExA", "GetVersionExW", "RegOpenKeyExA", "RegOpenKeyExW",
    "GetModuleHandleA", "GetModuleHandleW", "LoadLibraryA", "LoadLibraryW"
};

const std::vector<std::string> PEMalwareAnalysisEngine::INJECTION_IMPORTS = {
    "VirtualAllocEx", "WriteProcessMemory", "CreateRemoteThread", "OpenProcess",
    "VirtualProtectEx", "ReadProcessMemory", "SetWindowsHookExA", "SetWindowsHookExW",
    "MapViewOfFile", "UnmapViewOfFile", "NtWriteVirtualMemory", "NtAllocateVirtualMemory"
};

const std::vector<std::string> PEMalwareAnalysisEngine::CRYPTO_IMPORTS = {
    "CryptAcquireContextA", "CryptAcquireContextW", "CryptCreateHash", "CryptEncrypt",
    "CryptDecrypt", "CryptImportKey", "CryptExportKey", "BCryptOpenAlgorithmProvider",
    "BCryptEncrypt", "BCryptDecrypt", "BCryptGenerateSymmetricKey"
};

const std::vector<std::string> PEMalwareAnalysisEngine::NETWORK_IMPORTS = {
    "WSAStartup", "socket", "connect", "send", "recv", "InternetOpenA", "InternetOpenW",
    "InternetConnectA", "InternetConnectW", "HttpOpenRequestA", "HttpOpenRequestW",
    "InternetReadFile", "URLDownloadToFileA", "URLDownloadToFileW"
};

const std::vector<std::string> PEMalwareAnalysisEngine::REGISTRY_IMPORTS = {
    "RegCreateKeyExA", "RegCreateKeyExW", "RegSetValueExA", "RegSetValueExW",
    "RegDeleteKeyA", "RegDeleteKeyW", "RegDeleteValueA", "RegDeleteValueW"
};

const std::vector<std::string> PEMalwareAnalysisEngine::FILE_IMPORTS = {
    "CreateFileA", "CreateFileW", "WriteFile", "ReadFile", "DeleteFileA",
    "DeleteFileW", "MoveFileA", "MoveFileW", "CopyFileA", "CopyFileW",
    "FindFirstFileA", "FindFirstFileW", "SetFileAttributesA", "SetFileAttributesW"
};

int AnalyzeMalware(PPE_FILE_INFO pFileInfo) {
    LOGF("\n[+] MALWARE ANALYSIS ENGINE\n");
    LOGF_DEBUG("[DEBUG] Starting comprehensive malware analysis\n");

    if (!pFileInfo || !pFileInfo->ntHeader) {
        LOGF("[-] ERROR: Invalid PE file info\n");
        return PE_ERROR_INVALID_PE;
    }

    try {
        auto result = PEMalwareAnalysisEngine::analyzeFile(pFileInfo);
        PEMalwareAnalysisEngine::logMalwareAnalysis(result);
        LOGF("[+] Malware analysis completed successfully!\n");
        return PE_SUCCESS;
    }
    catch (const std::exception& e) {
        LOGF("[-] ERROR: Malware analysis failed: %s\n", e.what());
        return PE_ERROR_PARSING;
    }
}

PEMalwareAnalysisEngine::MalwareAnalysisResult PEMalwareAnalysisEngine::analyzeFile(PPE_FILE_INFO pFileInfo) {
    MalwareAnalysisResult result = {};
    result.isSuspicious = false;
    result.riskScore = 0;

    if (!pFileInfo) {
        result.classification = "Analysis Failed";
        result.recommendation = "Unable to analyze file";
        return result;
    }

    auto packerIndicators = detectPackers(pFileInfo);
    auto antiAnalysisIndicators = detectAntiAnalysis(pFileInfo);
    auto importIndicators = detectSuspiciousImports(pFileInfo);
    auto sectionIndicators = detectSuspiciousSections(pFileInfo);
    auto obfuscationIndicators = detectObfuscation(pFileInfo);

    result.indicators.insert(result.indicators.end(), packerIndicators.begin(), packerIndicators.end());
    result.indicators.insert(result.indicators.end(), antiAnalysisIndicators.begin(), antiAnalysisIndicators.end());
    result.indicators.insert(result.indicators.end(), importIndicators.begin(), importIndicators.end());
    result.indicators.insert(result.indicators.end(), sectionIndicators.begin(), sectionIndicators.end());
    result.indicators.insert(result.indicators.end(), obfuscationIndicators.begin(), obfuscationIndicators.end());

    result.riskScore = calculateRiskScore(result.indicators);
    result.isSuspicious = result.riskScore > 30 || hasHighSeverityIndicators(result.indicators);
    result.classification = classifyMalware(result);
    result.recommendation = generateRecommendation(result.riskScore, result.classification);

    result.metadata["architecture"] = pFileInfo->is64Bit ? "x64" : "x86";
    result.metadata["total_indicators"] = std::to_string(result.indicators.size());
    result.metadata["analysis_version"] = "1.0";

    return result;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectPackers(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;
    if (!pFileInfo) return indicators;

    extern int g_NumberOfSections;
    extern PIMAGE_SECTION_HEADER g_SectionHeader;

    if (!g_SectionHeader) return indicators;

    for (int i = 0; i < g_NumberOfSections; i++) {
        char sectionName[9] = {0};
        strncpy(sectionName, (char*)g_SectionHeader[i].Name, 8);

        for (const auto& packer : KNOWN_PACKERS) {
            if (strstr(sectionName, packer.c_str()) != nullptr) {
                MalwareIndicator indicator;
                indicator.category = "Packer Detection";
                indicator.description = "Known packer signature detected";
                indicator.severity = 7;
                indicator.evidence = "Section name: " + std::string(sectionName) + " (matches " + packer + ")";
                indicator.isDetected = true;
                indicators.push_back(indicator);
            }
        }
    }

    if (isSuspiciousEntryPoint(pFileInfo)) {
        MalwareIndicator indicator;
        indicator.category = "Packer Detection";
        indicator.description = "Entry point in suspicious section";
        indicator.severity = 6;
        indicator.evidence = "Entry point not in .text section";
        indicator.isDetected = true;
        indicators.push_back(indicator);
    }

    return indicators;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectAntiAnalysis(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;
    if (!pFileInfo) return indicators;

    if (hasAntiDebugImports(pFileInfo)) {
        MalwareIndicator indicator;
        indicator.category = "Anti-Analysis";
        indicator.description = "Anti-debugging imports detected";
        indicator.severity = 8;
        indicator.evidence = "Functions like IsDebuggerPresent, CheckRemoteDebuggerPresent found";
        indicator.isDetected = true;
        indicators.push_back(indicator);
    }

    if (hasAntiVMImports(pFileInfo)) {
        MalwareIndicator indicator;
        indicator.category = "Anti-Analysis";
        indicator.description = "Anti-VM detection patterns found";
        indicator.severity = 7;
        indicator.evidence = "VM detection techniques present";
        indicator.isDetected = true;
        indicators.push_back(indicator);
    }

    return indicators;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectSuspiciousImports(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;
    if (!pFileInfo) return indicators;

    if (hasInjectionIndicators(pFileInfo)) {
        MalwareIndicator indicator;
        indicator.category = "Suspicious Imports";
        indicator.description = "Process injection capabilities detected";
        indicator.severity = 9;
        indicator.evidence = "VirtualAllocEx, WriteProcessMemory, CreateRemoteThread found";
        indicator.isDetected = true;
        indicators.push_back(indicator);
    }

    if (hasHollowingIndicators(pFileInfo)) {
        MalwareIndicator indicator;
        indicator.category = "Suspicious Imports";
        indicator.description = "Process hollowing capabilities detected";
        indicator.severity = 9;
        indicator.evidence = "Process manipulation functions found";
        indicator.isDetected = true;
        indicators.push_back(indicator);
    }

    return indicators;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectSuspiciousSections(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;
    if (!pFileInfo) return indicators;

    extern PIMAGE_SECTION_HEADER g_SectionHeader;

    if (!g_SectionHeader) return indicators;

    if (hasCodeInDataSections(pFileInfo)) {
        MalwareIndicator indicator;
        indicator.category = "Suspicious Sections";
        indicator.description = "Executable code in data sections";
        indicator.severity = 7;
        indicator.evidence = "High entropy in non-executable sections";
        indicator.isDetected = true;
        indicators.push_back(indicator);
    }

    return indicators;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectObfuscation(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;
    if (!pFileInfo) return indicators;

    extern int g_CorruptedImports;
    extern int g_InvalidDLLNames;

    if (g_CorruptedImports > 50 || g_InvalidDLLNames > 2) {
        MalwareIndicator indicator;
        indicator.category = "Obfuscation";
        indicator.description = "Import table obfuscation detected";
        indicator.severity = 8;
        indicator.evidence = "Corrupted import table entries detected during parsing";
        indicator.isDetected = true;
        indicators.push_back(indicator);
    }

    return indicators;
}


bool PEMalwareAnalysisEngine::hasAntiDebugImports(PPE_FILE_INFO pFileInfo) {
    if (!pFileInfo || !pFileInfo->ntHeader) {
        return false;
    }


    extern int g_CorruptedImports;
    extern int g_InvalidDLLNames;


    if (g_CorruptedImports > 50 || g_InvalidDLLNames > 5) {
        return true;
    }

    return false;
}

bool PEMalwareAnalysisEngine::hasAntiVMImports(PPE_FILE_INFO pFileInfo) {
    if (!pFileInfo || !pFileInfo->ntHeader) {
        return false;
    }


    extern int g_CorruptedImports;


    if (g_CorruptedImports > 20) {
        return true;
    }

    return false;
}

bool PEMalwareAnalysisEngine::hasInjectionIndicators(PPE_FILE_INFO pFileInfo) {
    if (!pFileInfo || !pFileInfo->ntHeader) {
        return false;
    }


    PIMAGE_DATA_DIRECTORY importDir = nullptr;
    if (pFileInfo->is64Bit) {
        auto pNtHeader64 = (PIMAGE_NT_HEADERS64)pFileInfo->ntHeader;
        importDir = &pNtHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
    } else {
        auto pNtHeader32 = (PIMAGE_NT_HEADERS32)pFileInfo->ntHeader;
        importDir = &pNtHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
    }


    if (importDir && importDir->Size > 0x5000) {
        return true;
    }


    return isSuspiciousEntryPoint(pFileInfo);
}

bool PEMalwareAnalysisEngine::hasHollowingIndicators(PPE_FILE_INFO pFileInfo) {
    if (!pFileInfo || !pFileInfo->ntHeader) {
        return false;
    }


    bool suspiciousEntry = isSuspiciousEntryPoint(pFileInfo);
    bool codeInData = hasCodeInDataSections(pFileInfo);

    return suspiciousEntry && codeInData;
}

bool PEMalwareAnalysisEngine::isSuspiciousEntryPoint(PPE_FILE_INFO pFileInfo) {
    if (!pFileInfo || !pFileInfo->ntHeader) {
        return false;
    }

    DWORD entryPoint = 0;
    if (pFileInfo->is64Bit) {
        auto pNtHeader64 = (PIMAGE_NT_HEADERS64)pFileInfo->ntHeader;
        entryPoint = pNtHeader64->OptionalHeader.AddressOfEntryPoint;
    } else {
        auto pNtHeader32 = (PIMAGE_NT_HEADERS32)pFileInfo->ntHeader;
        entryPoint = pNtHeader32->OptionalHeader.AddressOfEntryPoint;
    }

    if (entryPoint == 0) {
        return true;
    }


    extern int g_NumberOfSections;
    extern PIMAGE_SECTION_HEADER g_SectionHeader;

    if (g_SectionHeader) {
        for (int i = 0; i < g_NumberOfSections; i++) {
            char sectionName[9] = {0};
            strncpy(sectionName, (char*)g_SectionHeader[i].Name, 8);


            if (strcmp(sectionName, ".text") == 0) {
                DWORD sectionStart = g_SectionHeader[i].VirtualAddress;
                DWORD sectionEnd = sectionStart + g_SectionHeader[i].Misc.VirtualSize;

                if (entryPoint >= sectionStart && entryPoint < sectionEnd) {
                    return false;
                }
            }
        }
    }

    return true;
}

bool PEMalwareAnalysisEngine::hasCodeInDataSections(PPE_FILE_INFO pFileInfo) {
    if (!pFileInfo || !pFileInfo->ntHeader) {
        return false;
    }

    extern int g_NumberOfSections;
    extern PIMAGE_SECTION_HEADER g_SectionHeader;

    if (!g_SectionHeader) {
        return false;
    }

    for (int i = 0; i < g_NumberOfSections; i++) {
        char sectionName[9] = {0};
        strncpy(sectionName, (char*)g_SectionHeader[i].Name, 8);


        DWORD characteristics = g_SectionHeader[i].Characteristics;
        bool isExecutable = (characteristics & IMAGE_SCN_MEM_EXECUTE) != 0;
        bool isDataSection = (strcmp(sectionName, ".data") == 0 ||
                            strcmp(sectionName, ".rdata") == 0 ||
                            strcmp(sectionName, ".rsrc") == 0);

        if (isDataSection && isExecutable) {
            return true;
        }


        if (isDataSection && g_SectionHeader[i].SizeOfRawData > 0) {
            BYTE* sectionData = (BYTE*)((DWORD_PTR)pFileInfo->dosHeader + g_SectionHeader[i].PointerToRawData);
            double entropy = calculateSectionEntropy(sectionData, g_SectionHeader[i].SizeOfRawData);
            if (entropy > 7.0) {
                return true;
            }
        }
    }

    return false;
}

bool PEMalwareAnalysisEngine::hasSuspiciousStrings(PPE_FILE_INFO pFileInfo) {
    if (!pFileInfo || !pFileInfo->fileContent) {
        return false;
    }


    const std::vector<std::string> SUSPICIOUS_STRINGS = {

        "http://", "https://", "ftp://", "tcp://", "udp://",
        "cmd.exe", "powershell", "wscript", "cscript",


        "bitcoin", "wallet", "cryptocurrency", "mining",
        "encrypt", "decrypt", "ransom", "payment",


        "HKEY_LOCAL_MACHINE", "HKEY_CURRENT_USER", "Software\\Microsoft\\Windows\\CurrentVersion\\Run",


        "vmware", "virtualbox", "sandbox", "wireshark", "procmon",
        "ollydbg", "x64dbg", "ida", "debug",


        "keylogger", "backdoor", "trojan", "virus", "malware",
        "botnet", "c&c", "command and control", "shellcode",


        "temp\\", "appdata\\", "system32\\", "syswow64\\",
        "startup\\", "autostart"
    };

    const std::vector<std::string> IP_PATTERNS = {

        "192.168.", "10.0.", "172.16.", "127.0.0.1"
    };


    std::string fileContent((char*)pFileInfo->fileContent,
                           std::min(pFileInfo->fileSize, (DWORD)1048576));


    std::transform(fileContent.begin(), fileContent.end(), fileContent.begin(), ::tolower);

    int suspiciousStringCount = 0;


    for (const auto& suspiciousString : SUSPICIOUS_STRINGS) {
        std::string lowerString = suspiciousString;
        std::transform(lowerString.begin(), lowerString.end(), lowerString.begin(), ::tolower);

        if (fileContent.find(lowerString) != std::string::npos) {
            suspiciousStringCount++;
            if (suspiciousStringCount >= 3) {
                return true;
            }
        }
    }


    for (const auto& ipPattern : IP_PATTERNS) {
        if (fileContent.find(ipPattern) != std::string::npos) {
            suspiciousStringCount++;
            if (suspiciousStringCount >= 3) {
                return true;
            }
        }
    }


    size_t base64Count = 0;
    size_t consecutiveBase64 = 0;

    for (char c : fileContent) {
        if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') ||
            (c >= '0' && c <= '9') || c == '+' || c == '/' || c == '=') {
            consecutiveBase64++;
            if (consecutiveBase64 > 100) {
                base64Count++;
                consecutiveBase64 = 0;
                if (base64Count >= 3) {
                    return true;
                }
            }
        } else {
            consecutiveBase64 = 0;
        }
    }

    return false;
}


double PEMalwareAnalysisEngine::calculateSectionEntropy(const BYTE* data, size_t size) {
    if (!data || size == 0) return 0.0;

    unsigned int frequency[256] = {0};
    for (size_t i = 0; i < size; i++) {
        frequency[data[i]]++;
    }

    double entropy = 0.0;
    for (int i = 0; i < 256; i++) {
        if (frequency[i] > 0) {
            double probability = (double)frequency[i] / size;
            entropy -= probability * log2(probability);
        }
    }

    return entropy;
}

int PEMalwareAnalysisEngine::calculateRiskScore(const std::vector<MalwareIndicator>& indicators) {
    int score = 0;
    for (const auto& indicator : indicators) {
        if (indicator.isDetected) {
            if (indicator.category == "Packer Detection") {
                score += PACKER_WEIGHT;
            } else if (indicator.category == "Anti-Analysis") {
                score += ANTI_ANALYSIS_WEIGHT;
            } else if (indicator.category == "Suspicious Imports") {
                score += SUSPICIOUS_IMPORTS_WEIGHT;
            } else if (indicator.category == "Suspicious Sections") {
                score += SUSPICIOUS_SECTIONS_WEIGHT;
            } else if (indicator.category == "Obfuscation") {
                score += OBFUSCATION_WEIGHT;
            }
        }
    }
    return std::min(score, 100);
}

std::string PEMalwareAnalysisEngine::classifyMalware(const MalwareAnalysisResult& result) {
    if (result.riskScore <= 10) {
        return "Clean/Low Risk";
    } else if (result.riskScore <= 40) {
        return "Suspicious";
    } else if (result.riskScore <= 70) {
        return "Likely Malware";
    } else {
        return "High Risk Malware";
    }
}

std::string PEMalwareAnalysisEngine::generateRecommendation(int riskScore, const std::string& classification) {
    (void)classification;

    if (riskScore <= 10) {
        return "File appears clean. Standard security practices apply.";
    } else if (riskScore <= 40) {
        return "Exercise caution. Consider additional analysis with behavioral tools.";
    } else if (riskScore <= 70) {
        return "High risk file. Recommend sandboxed analysis and avoid execution.";
    } else {
        return "DANGEROUS: Do not execute. Quarantine and analyze in isolated environment.";
    }
}

void PEMalwareAnalysisEngine::logMalwareAnalysis(const MalwareAnalysisResult& analysisResult) {
    LOGF("\tRisk Score: %d/100\n", analysisResult.riskScore);
    LOGF("\tClassification: %s\n", analysisResult.classification.c_str());
    LOGF("\tSuspicious: %s\n", analysisResult.isSuspicious ? "YES" : "NO");

    if (!analysisResult.indicators.empty()) {
        LOGF("\tThreat Indicators (%zu found):\n", analysisResult.indicators.size());
        for (const auto& indicator : analysisResult.indicators) {
            if (indicator.isDetected) {
                LOGF("\t\t[%s] %s (Severity: %d/10)\n",
                     indicator.category.c_str(),
                     indicator.description.c_str(),
                     indicator.severity);
                if (!indicator.evidence.empty()) {
                    LOGF("\t\t    Evidence: %s\n", indicator.evidence.c_str());
                }
            }
        }
    } else {
        LOGF("\tThreat Indicators: None detected\n");
    }

    LOGF("\tRecommendation: %s\n", analysisResult.recommendation.c_str());
}

bool PEMalwareAnalysisEngine::hasHighSeverityIndicators(const std::vector<MalwareIndicator>& indicators) {
    for (const auto& indicator : indicators) {
        if (indicator.severity >= 8) {
            return true;
        }
    }
    return false;
}


std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectEntropyAnomalies(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;

    if (!pFileInfo || !pFileInfo->ntHeader) {
        return indicators;
    }

    PIMAGE_SECTION_HEADER pSectionHeader;
    int numberOfSections;

    if (pFileInfo->is64Bit) {
        auto pNtHeader64 = (PIMAGE_NT_HEADERS64)pFileInfo->ntHeader;
        numberOfSections = pNtHeader64->FileHeader.NumberOfSections;
        pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)pNtHeader64 + 4 + sizeof(IMAGE_FILE_HEADER) + pNtHeader64->FileHeader.SizeOfOptionalHeader);
    } else {
        auto pNtHeader32 = (PIMAGE_NT_HEADERS32)pFileInfo->ntHeader;
        numberOfSections = pNtHeader32->FileHeader.NumberOfSections;
        pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)pNtHeader32 + 4 + sizeof(IMAGE_FILE_HEADER) + pNtHeader32->FileHeader.SizeOfOptionalHeader);
    }

    std::vector<double> sectionEntropies;
    std::vector<std::string> sectionNames;


    for (int i = 0; i < numberOfSections; i++) {
        std::string sectionName(reinterpret_cast<const char*>(pSectionHeader[i].Name), 8);
        sectionName = sectionName.substr(0, sectionName.find('\0'));
        sectionNames.push_back(sectionName);


        const uint8_t* sectionData = reinterpret_cast<const uint8_t*>(pFileInfo->dosHeader) + pSectionHeader[i].PointerToRawData;
        size_t sectionSize = pSectionHeader[i].SizeOfRawData;

        if (sectionSize == 0) {
            sectionEntropies.push_back(0.0);
            continue;
        }


        std::vector<int> frequency(256, 0);
        for (size_t j = 0; j < sectionSize && j < 65536; j++) {
            frequency[sectionData[j]]++;
        }


        double entropy = 0.0;
        size_t totalBytes = std::min(sectionSize, static_cast<size_t>(65536));
        for (int freq : frequency) {
            if (freq > 0) {
                double probability = static_cast<double>(freq) / totalBytes;
                entropy -= probability * log2(probability);
            }
        }

        sectionEntropies.push_back(entropy);
    }


    if (!sectionEntropies.empty()) {

        for (size_t i = 0; i < sectionEntropies.size(); i++) {
            if (sectionEntropies[i] > 7.5) {
                MalwareIndicator indicator;
                indicator.category = "High Entropy Section";
                indicator.description = "Section has very high entropy suggesting encryption or packing";
                indicator.evidence = "Section '" + sectionNames[i] + "' has entropy " + std::to_string(sectionEntropies[i]);
                indicator.severity = 7;
                indicators.push_back(indicator);
            }
        }


        double minEntropy = *std::min_element(sectionEntropies.begin(), sectionEntropies.end());
        double maxEntropy = *std::max_element(sectionEntropies.begin(), sectionEntropies.end());
        double entropyVariance = maxEntropy - minEntropy;

        if (entropyVariance > 4.0 && maxEntropy > 6.0) {
            MalwareIndicator indicator;
            indicator.category = "Entropy Variance";
            indicator.description = "Large entropy variance between sections";
            indicator.evidence = "Entropy range: " + std::to_string(minEntropy) + " - " + std::to_string(maxEntropy);
            indicator.severity = 6;
            indicators.push_back(indicator);
        }


        for (int i = 0; i < numberOfSections; i++) {
            if ((pSectionHeader[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) && sectionEntropies[i] > 6.5) {
                MalwareIndicator indicator;
                indicator.category = "High Entropy Executable";
                indicator.description = "Executable section has suspiciously high entropy";
                indicator.evidence = "Executable section '" + sectionNames[i] + "' entropy: " + std::to_string(sectionEntropies[i]);
                indicator.severity = 8;
                indicators.push_back(indicator);
            }
        }
    }

    return indicators;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectTimestampManipulation(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;

    if (!pFileInfo || !pFileInfo->ntHeader) {
        return indicators;
    }

    DWORD timestamp;
    if (pFileInfo->is64Bit) {
        auto pNtHeader64 = (PIMAGE_NT_HEADERS64)pFileInfo->ntHeader;
        timestamp = pNtHeader64->FileHeader.TimeDateStamp;
    } else {
        auto pNtHeader32 = (PIMAGE_NT_HEADERS32)pFileInfo->ntHeader;
        timestamp = pNtHeader32->FileHeader.TimeDateStamp;
    }


    const std::vector<DWORD> KNOWN_MALWARE_TIMESTAMPS = {
        0x4D4E196B,
        0x2A425E19,
        0x00000000,
        0xFFFFFFFF
    };


    for (DWORD malwareTimestamp : KNOWN_MALWARE_TIMESTAMPS) {
        if (timestamp == malwareTimestamp) {
            MalwareIndicator indicator;
            indicator.category = "Known Malware Timestamp";
            indicator.severity = (timestamp == 0x4D4E196B) ? 9 : 8;
            indicator.description = "Timestamp matches known malware signature";

            std::stringstream evidenceStream;
            evidenceStream << "Timestamp: 0x" << std::hex << timestamp;
            if (timestamp == 0x4D4E196B) {
                evidenceStream << " (WannaCry signature timestamp)";
            }
            indicator.evidence = evidenceStream.str();

            indicators.push_back(indicator);
            break;
        }
    }


    time_t pe_epoch = 631152000;
    if (timestamp != 0 && timestamp < pe_epoch) {
        MalwareIndicator indicator;
        indicator.category = "Anachronistic Timestamp";
        indicator.severity = 7;
        indicator.description = "Timestamp predates PE format existence";

        std::stringstream evidenceStream;
        evidenceStream << "Timestamp: 0x" << std::hex << timestamp << " (before 1990)";
        indicator.evidence = evidenceStream.str();

        indicators.push_back(indicator);
    }


    time_t current_time = time(nullptr);
    if (timestamp > current_time + 86400) {
        MalwareIndicator indicator;
        indicator.category = "Future Timestamp";
        indicator.severity = 6;
        indicator.description = "Compilation timestamp is in the future";

        std::stringstream evidenceStream;
        evidenceStream << "Timestamp: 0x" << std::hex << timestamp << " (future date)";
        indicator.evidence = evidenceStream.str();

        indicators.push_back(indicator);
    }

    return indicators;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectOverlayAnomalies(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;

    if (!pFileInfo || !pFileInfo->ntHeader || !pFileInfo->fileContent) {
        return indicators;
    }


    PIMAGE_SECTION_HEADER sectionHeader;
    int numberOfSections;

    if (pFileInfo->is64Bit) {
        auto pNtHeader64 = (PIMAGE_NT_HEADERS64)pFileInfo->ntHeader;
        numberOfSections = pNtHeader64->FileHeader.NumberOfSections;
        sectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)pNtHeader64 + 4 + sizeof(IMAGE_FILE_HEADER) + pNtHeader64->FileHeader.SizeOfOptionalHeader);
    } else {
        auto pNtHeader32 = (PIMAGE_NT_HEADERS32)pFileInfo->ntHeader;
        numberOfSections = pNtHeader32->FileHeader.NumberOfSections;
        sectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)pNtHeader32 + 4 + sizeof(IMAGE_FILE_HEADER) + pNtHeader32->FileHeader.SizeOfOptionalHeader);
    }


    DWORD lastSectionEnd = 0;
    for (int i = 0; i < numberOfSections; i++) {
        DWORD sectionEnd = sectionHeader[i].PointerToRawData + sectionHeader[i].SizeOfRawData;
        if (sectionEnd > lastSectionEnd) {
            lastSectionEnd = sectionEnd;
        }
    }


    if (lastSectionEnd < pFileInfo->fileSize) {
        size_t overlaySize = pFileInfo->fileSize - lastSectionEnd;


        if (overlaySize > 1024) {
            MalwareIndicator indicator;
            indicator.category = "Large Overlay Data";
            indicator.severity = (overlaySize > 100000) ? 8 : 6;
            indicator.description = "File contains significant data after last PE section";

            std::stringstream evidenceStream;
            evidenceStream << "Overlay size: " << overlaySize << " bytes starting at offset 0x"
                          << std::hex << lastSectionEnd;
            indicator.evidence = evidenceStream.str();

            indicators.push_back(indicator);
        }


        const BYTE* overlayData = (const BYTE*)pFileInfo->fileContent + lastSectionEnd;


        double overlayEntropy = calculateSectionEntropy(overlayData, std::min(overlaySize, (size_t)4096));
        if (overlayEntropy > 7.5) {
            MalwareIndicator indicator;
            indicator.category = "High Entropy Overlay";
            indicator.severity = 7;
            indicator.description = "Overlay contains high-entropy data (possible encryption)";

            std::stringstream evidenceStream;
            evidenceStream << "Overlay entropy: " << std::fixed << std::setprecision(2) << overlayEntropy;
            indicator.evidence = evidenceStream.str();

            indicators.push_back(indicator);
        }


        for (size_t i = 0; i < overlaySize - 4 && i < 4096; i++) {
            if (overlayData[i] == 'M' && overlayData[i+1] == 'Z') {
                MalwareIndicator indicator;
                indicator.category = "Embedded PE in Overlay";
                indicator.severity = 8;
                indicator.description = "Overlay contains embedded PE file signature";

                std::stringstream evidenceStream;
                evidenceStream << "PE signature found at overlay offset 0x" << std::hex << i;
                indicator.evidence = evidenceStream.str();

                indicators.push_back(indicator);
                break;
            }
        }
    }

    return indicators;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectAPIPatterns(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;

    if (!pFileInfo) {
        return indicators;
    }


    const std::vector<std::string> ANTI_DEBUG_APIS = {
        "IsDebuggerPresent", "CheckRemoteDebuggerPresent", "NtQueryInformationProcess",
        "OutputDebugStringA", "OutputDebugStringW", "GetTickCount", "QueryPerformanceCounter"
    };

    const std::vector<std::string> PROCESS_MANIPULATION_APIS = {
        "CreateProcess", "CreateRemoteThread", "WriteProcessMemory", "ReadProcessMemory",
        "VirtualAllocEx", "VirtualProtectEx", "SetWindowsHookEx", "EnumProcesses"
    };

    const std::vector<std::string> NETWORK_APIS = {
        "InternetOpen", "InternetConnect", "HttpOpenRequest", "WinHttpOpen",
        "socket", "connect", "send", "recv", "WSAStartup"
    };

    const std::vector<std::string> CRYPTO_APIS = {
        "CryptAcquireContext", "CryptCreateHash", "CryptHashData", "CryptEncrypt",
        "CryptDecrypt", "CryptGenKey", "CryptExportKey", "CryptImportKey"
    };

    const std::vector<std::string> PERSISTENCE_APIS = {
        "RegOpenKey", "RegSetValue", "RegCreateKey", "CreateService",
        "OpenSCManager", "StartService", "CreateFile", "WriteFile"
    };


    extern int g_CorruptedImports;
    extern int g_InvalidDLLNames;


    if (g_CorruptedImports > 0) {
        MalwareIndicator indicator;
        indicator.category = "API Obfuscation";
        indicator.description = "Import table corruption detected - possible API hiding";
        indicator.evidence = "Corrupted import entries: " + std::to_string(g_CorruptedImports);
        indicator.severity = 7;
        indicators.push_back(indicator);
    }


    if (g_InvalidDLLNames > 3) {
        MalwareIndicator indicator;
        indicator.category = "Dynamic Loading";
        indicator.description = "Multiple invalid DLL names suggest dynamic API resolution";
        indicator.evidence = "Invalid DLL names: " + std::to_string(g_InvalidDLLNames);
        indicator.severity = 6;
        indicators.push_back(indicator);
    }

    return indicators;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectStructuralAnomalies(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;

    if (!pFileInfo || !pFileInfo->dosHeader || !pFileInfo->ntHeader) {
        return indicators;
    }


    if (pFileInfo->dosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
        MalwareIndicator indicator;
        indicator.category = "Invalid DOS Signature";
        indicator.severity = 9;
        indicator.description = "DOS header has invalid magic signature";

        std::stringstream evidenceStream;
        evidenceStream << "Expected: 0x" << std::hex << IMAGE_DOS_SIGNATURE
                      << ", Found: 0x" << std::hex << pFileInfo->dosHeader->e_magic;
        indicator.evidence = evidenceStream.str();

        indicators.push_back(indicator);
    }


    DWORD ntSignature;
    if (pFileInfo->is64Bit) {
        auto pNtHeader64 = (PIMAGE_NT_HEADERS64)pFileInfo->ntHeader;
        ntSignature = pNtHeader64->Signature;
    } else {
        auto pNtHeader32 = (PIMAGE_NT_HEADERS32)pFileInfo->ntHeader;
        ntSignature = pNtHeader32->Signature;
    }

    if (ntSignature != IMAGE_NT_SIGNATURE) {
        MalwareIndicator indicator;
        indicator.category = "Invalid PE Signature";
        indicator.severity = 9;
        indicator.description = "PE header has invalid signature";

        std::stringstream evidenceStream;
        evidenceStream << "Expected: 0x" << std::hex << IMAGE_NT_SIGNATURE
                      << ", Found: 0x" << std::hex << ntSignature;
        indicator.evidence = evidenceStream.str();

        indicators.push_back(indicator);
    }


    DWORD e_lfanew = pFileInfo->dosHeader->e_lfanew;
    if (e_lfanew > pFileInfo->fileSize - sizeof(IMAGE_NT_HEADERS32)) {
        MalwareIndicator indicator;
        indicator.category = "Invalid e_lfanew Offset";
        indicator.severity = 8;
        indicator.description = "DOS header e_lfanew points beyond file bounds";

        std::stringstream evidenceStream;
        evidenceStream << "e_lfanew: 0x" << std::hex << e_lfanew
                      << ", File size: 0x" << std::hex << pFileInfo->fileSize;
        indicator.evidence = evidenceStream.str();

        indicators.push_back(indicator);
    }


    int numberOfSections;
    if (pFileInfo->is64Bit) {
        auto pNtHeader64 = (PIMAGE_NT_HEADERS64)pFileInfo->ntHeader;
        numberOfSections = pNtHeader64->FileHeader.NumberOfSections;
    } else {
        auto pNtHeader32 = (PIMAGE_NT_HEADERS32)pFileInfo->ntHeader;
        numberOfSections = pNtHeader32->FileHeader.NumberOfSections;
    }

    if (numberOfSections == 0) {
        MalwareIndicator indicator;
        indicator.category = "No PE Sections";
        indicator.severity = 9;
        indicator.description = "PE file has no sections defined";
        indicator.evidence = "NumberOfSections: 0";
        indicators.push_back(indicator);
    } else if (numberOfSections > 96) {
        MalwareIndicator indicator;
        indicator.category = "Excessive Section Count";
        indicator.severity = 7;
        indicator.description = "PE file has unusually high number of sections";

        std::stringstream evidenceStream;
        evidenceStream << "NumberOfSections: " << numberOfSections << " (>96 is unusual)";
        indicator.evidence = evidenceStream.str();

        indicators.push_back(indicator);
    }


    DWORD entryPoint;
    if (pFileInfo->is64Bit) {
        auto pNtHeader64 = (PIMAGE_NT_HEADERS64)pFileInfo->ntHeader;
        entryPoint = pNtHeader64->OptionalHeader.AddressOfEntryPoint;
    } else {
        auto pNtHeader32 = (PIMAGE_NT_HEADERS32)pFileInfo->ntHeader;
        entryPoint = pNtHeader32->OptionalHeader.AddressOfEntryPoint;
    }

    if (entryPoint == 0) {
        MalwareIndicator indicator;
        indicator.category = "Zero Entry Point";
        indicator.severity = 6;
        indicator.description = "Entry point address is zero (DLL or malformed)";
        indicator.evidence = "AddressOfEntryPoint: 0x00000000";
        indicators.push_back(indicator);
    }

    return indicators;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectStringAnomalies(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;

    if (!pFileInfo || !pFileInfo->dosHeader) {
        return indicators;
    }


    const std::vector<std::string> SUSPICIOUS_STRINGS = {
        "payload", "exploit", "shell", "backdoor", "trojan", "virus",
        "keylog", "stealer", "botnet", "rootkit", "ransomware", "miner",
        "debug.exe", "taskkill", "net user", "reg add", "schtasks",
        "powershell", "cmd.exe", "rundll32", "regsvr32", "certutil"
    };

    const std::vector<std::string> OBFUSCATION_PATTERNS = {
        "aaaaaaa", "1111111", "xxxxxxx", "0000000",
        "base64", "decode", "encode", "decrypt", "unpack"
    };


    const char* fileData = reinterpret_cast<const char*>(pFileInfo->dosHeader);
    size_t fileSize = 0;


    if (pFileInfo->ntHeader) {
        PIMAGE_SECTION_HEADER pSectionHeader;
        int numberOfSections;

        if (pFileInfo->is64Bit) {
            auto pNtHeader64 = (PIMAGE_NT_HEADERS64)pFileInfo->ntHeader;
            numberOfSections = pNtHeader64->FileHeader.NumberOfSections;
            pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)pNtHeader64 + 4 + sizeof(IMAGE_FILE_HEADER) + pNtHeader64->FileHeader.SizeOfOptionalHeader);
        } else {
            auto pNtHeader32 = (PIMAGE_NT_HEADERS32)pFileInfo->ntHeader;
            numberOfSections = pNtHeader32->FileHeader.NumberOfSections;
            pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)pNtHeader32 + 4 + sizeof(IMAGE_FILE_HEADER) + pNtHeader32->FileHeader.SizeOfOptionalHeader);
        }


        for (int i = 0; i < numberOfSections; i++) {
            size_t sectionEnd = pSectionHeader[i].PointerToRawData + pSectionHeader[i].SizeOfRawData;
            if (sectionEnd > fileSize) {
                fileSize = sectionEnd;
            }
        }
    }


    if (fileSize > 1024 * 1024) {
        fileSize = 1024 * 1024;
    }

    int suspiciousStringCount = 0;
    int obfuscationStringCount = 0;


    std::string currentString;
    for (size_t i = 0; i < fileSize; i++) {
        char c = fileData[i];
        if (c >= 32 && c <= 126) {
            currentString += c;
        } else {
            if (currentString.length() >= 4) {

                std::string lowerStr = currentString;
                std::transform(lowerStr.begin(), lowerStr.end(), lowerStr.begin(), ::tolower);


                for (const auto& suspiciousStr : SUSPICIOUS_STRINGS) {
                    if (lowerStr.find(suspiciousStr) != std::string::npos) {
                        suspiciousStringCount++;
                        break;
                    }
                }


                for (const auto& obfPattern : OBFUSCATION_PATTERNS) {
                    if (lowerStr.find(obfPattern) != std::string::npos) {
                        obfuscationStringCount++;
                        break;
                    }
                }
            }
            currentString.clear();
        }
    }


    if (suspiciousStringCount > 2) {
        MalwareIndicator indicator;
        indicator.category = "Suspicious Strings";
        indicator.description = "Multiple suspicious strings found in file";
        indicator.evidence = "Found " + std::to_string(suspiciousStringCount) + " suspicious string patterns";
        indicator.severity = (suspiciousStringCount > 5) ? 8 : 6;
        indicators.push_back(indicator);
    }

    if (obfuscationStringCount > 1) {
        MalwareIndicator indicator;
        indicator.category = "String Obfuscation";
        indicator.description = "Possible string obfuscation patterns detected";
        indicator.evidence = "Found " + std::to_string(obfuscationStringCount) + " obfuscation indicators";
        indicator.severity = 7;
        indicators.push_back(indicator);
    }

    return indicators;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectSectionAnomalies(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;

    if (!pFileInfo || !pFileInfo->ntHeader) {
        return indicators;
    }

    PIMAGE_SECTION_HEADER sectionHeader;
    int numberOfSections;

    if (pFileInfo->is64Bit) {
        auto pNtHeader64 = (PIMAGE_NT_HEADERS64)pFileInfo->ntHeader;
        numberOfSections = pNtHeader64->FileHeader.NumberOfSections;
        sectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)pNtHeader64 + 4 + sizeof(IMAGE_FILE_HEADER) + pNtHeader64->FileHeader.SizeOfOptionalHeader);
    } else {
        auto pNtHeader32 = (PIMAGE_NT_HEADERS32)pFileInfo->ntHeader;
        numberOfSections = pNtHeader32->FileHeader.NumberOfSections;
        sectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)pNtHeader32 + 4 + sizeof(IMAGE_FILE_HEADER) + pNtHeader32->FileHeader.SizeOfOptionalHeader);
    }

    for (int i = 0; i < numberOfSections; i++) {

        DWORD characteristics = sectionHeader[i].Characteristics;
        bool isReadable = (characteristics & IMAGE_SCN_MEM_READ) != 0;
        bool isWritable = (characteristics & IMAGE_SCN_MEM_WRITE) != 0;
        bool isExecutable = (characteristics & IMAGE_SCN_MEM_EXECUTE) != 0;

        if (isReadable && isWritable && isExecutable) {
            MalwareIndicator indicator;
            indicator.category = "RWX Section Detected";
            indicator.severity = 8;
            indicator.description = "Section has Read, Write, and Execute permissions";

            std::stringstream evidenceStream;
            evidenceStream << "Section: " << std::string((char*)sectionHeader[i].Name, 8)
                          << ", Characteristics: 0x" << std::hex << characteristics;
            indicator.evidence = evidenceStream.str();

            indicators.push_back(indicator);
        }


        std::string sectionName((char*)sectionHeader[i].Name, 8);
        sectionName = sectionName.substr(0, sectionName.find('\0'));


        const std::vector<std::string> PACKER_SECTIONS = {
            "UPX0", "UPX1", "UPX2", ".aspack", ".adata", ".ASPack",
            ".ccg", ".boom", ".fake", ".nsp0", ".nsp1", ".nsp2",
            "MEW", ".MPRESS1", ".MPRESS2", ".vmp0", ".vmp1", ".vmp2"
        };

        for (const auto& packerSection : PACKER_SECTIONS) {
            if (sectionName.find(packerSection) != std::string::npos) {
                MalwareIndicator indicator;
                indicator.category = "Packer Section Name";
                indicator.severity = 7;
                indicator.description = "Section name indicates packer usage";

                std::stringstream evidenceStream;
                evidenceStream << "Section: " << sectionName << " (matches " << packerSection << ")";
                indicator.evidence = evidenceStream.str();

                indicators.push_back(indicator);
                break;
            }
        }


        if (sectionHeader[i].Misc.VirtualSize == 0 && sectionHeader[i].SizeOfRawData > 0) {
            MalwareIndicator indicator;
            indicator.category = "Zero Virtual Size Section";
            indicator.severity = 6;
            indicator.description = "Section has zero virtual size but contains raw data";

            std::stringstream evidenceStream;
            evidenceStream << "Section: " << sectionName
                          << ", Virtual Size: 0, Raw Size: " << sectionHeader[i].SizeOfRawData;
            indicator.evidence = evidenceStream.str();

            indicators.push_back(indicator);
        }


        if (sectionHeader[i].SizeOfRawData > 50 * 1024 * 1024) {
            MalwareIndicator indicator;
            indicator.category = "Extremely Large Section";
            indicator.severity = 5;
            indicator.description = "Section size is unusually large";

            std::stringstream evidenceStream;
            evidenceStream << "Section: " << sectionName
                          << ", Size: " << (sectionHeader[i].SizeOfRawData / (1024*1024)) << " MB";
            indicator.evidence = evidenceStream.str();

            indicators.push_back(indicator);
        }


        if (sectionHeader[i].PointerToRawData % 512 != 0 && sectionHeader[i].PointerToRawData != 0) {
            MalwareIndicator indicator;
            indicator.category = "Poor Section Alignment";
            indicator.severity = 4;
            indicator.description = "Section not aligned to file sector boundary";

            std::stringstream evidenceStream;
            evidenceStream << "Section: " << sectionName
                          << ", Raw Offset: 0x" << std::hex << sectionHeader[i].PointerToRawData;
            indicator.evidence = evidenceStream.str();

            indicators.push_back(indicator);
        }
    }

    return indicators;
}

std::string PEMalwareAnalysisEngine::generateDetailedReport(const MalwareAnalysisResult& result) {
    std::stringstream report;

    report << "\n=== DETAILED MALWARE ANALYSIS REPORT ===\n";
    std::time_t now = std::time(nullptr);
    report << "Analysis Date: " << std::ctime(&now);
    report << "Risk Score: " << result.riskScore << "/100\n";
    report << "Classification: " << result.classification << "\n";
    report << "Suspicious: " << (result.isSuspicious ? "YES" : "NO") << "\n\n";

    if (!result.indicators.empty()) {
        report << "THREAT INDICATORS FOUND (" << result.indicators.size() << "):\n";
        report << "========================================\n";

        for (size_t i = 0; i < result.indicators.size(); i++) {
            const auto& indicator = result.indicators[i];

            report << "[" << (i + 1) << "] " << indicator.category << "\n";
            report << "    Severity: " << indicator.severity << "/10\n";
            report << "    Description: " << indicator.description << "\n";
            report << "    Evidence: " << indicator.evidence << "\n";


            if (indicator.severity >= 8) {
                report << "    Risk Level: HIGH\n";
            } else if (indicator.severity >= 6) {
                report << "    Risk Level: MEDIUM\n";
            } else {
                report << "    Risk Level: LOW\n";
            }
            report << "\n";
        }
    } else {
        report << "NO THREAT INDICATORS DETECTED\n";
        report << "This file appears to be clean based on current analysis.\n\n";
    }


    report << "RECOMMENDATIONS:\n";
    report << "================\n";

    if (result.riskScore >= 70) {
        report << "   HIGH RISK - This file is likely malicious\n";
        report << "   • DO NOT EXECUTE this file\n";
        report << "   • Isolate the file immediately\n";
        report << "   • Submit to antivirus vendors for analysis\n";
        report << "   • Consider forensic analysis\n";
    } else if (result.riskScore >= 40) {
        report << "   MEDIUM RISK - This file shows suspicious characteristics\n";
        report << "   • Exercise extreme caution\n";
        report << "   • Execute only in isolated environment\n";
        report << "   • Monitor system behavior if executed\n";
        report << "   • Scan with multiple antivirus engines\n";
    } else {
        report << "   LOW RISK - This file appears relatively safe\n";
        report << "   • File shows minimal suspicious indicators\n";
        report << "   • Standard security precautions recommended\n";
        report << "   • Regular antivirus scanning advised\n";
    }

    report << "\n";
    report << "TECHNICAL ANALYSIS SUMMARY:\n";
    report << "===========================\n";


    std::map<std::string, int> indicatorTypes;
    for (const auto& indicator : result.indicators) {
        indicatorTypes[indicator.category]++;
    }

    if (!indicatorTypes.empty()) {
        report << "Indicators by Category:\n";
        for (const auto& pair : indicatorTypes) {
            report << "  • " << pair.first << ": " << pair.second << " finding(s)\n";
        }
    }

    report << "\nAnalysis Confidence: ";
    if (result.indicators.size() >= 3) {
        report << "HIGH (Multiple indicators detected)\n";
    } else if (result.indicators.size() >= 1) {
        report << "MEDIUM (Some indicators detected)\n";
    } else {
        report << "LOW (Limited indicators available)\n";
    }

    report << "\nNote: This analysis is based on static file analysis.\n";
    report << "Dynamic analysis in a sandbox environment is recommended\n";
    report << "for comprehensive threat assessment.\n";

    report << "\n=== END OF DETAILED REPORT ===\n";

    return report.str();
}

std::string PEMalwareAnalysisEngine::generateSummaryReport(const MalwareAnalysisResult& result) {
    std::stringstream report;


    report << "\n=== MALWARE ANALYSIS SUMMARY REPORT ===\n";
    report << "Analysis Engine: PE Malware Detection v4.0.0\n";
    report << "Scan Timestamp: ";


    auto now = std::chrono::system_clock::now();
    std::time_t time = std::chrono::system_clock::to_time_t(now);
    report << std::ctime(&time);


    report << "\n--- RISK ASSESSMENT ---\n";


    std::string riskLevel = "LOW";
    if (result.riskScore >= 80) {
        riskLevel = "CRITICAL";
    } else if (result.riskScore >= 60) {
        riskLevel = "HIGH";
    } else if (result.riskScore >= 30) {
        riskLevel = "MEDIUM";
    }

    report << "Risk Level: " << riskLevel << "\n";
    report << "Risk Score: " << result.riskScore << "/100\n";
    report << "Classification: " << (result.classification.empty() ? "Unknown" : result.classification) << "\n";
    report << "Suspicious Status: " << (result.isSuspicious ? "YES" : "NO") << "\n";


    report << "\n--- KEY FINDINGS ---\n";


    if (result.entropyScore > 0) {
        report << "• Overall Entropy Score: " << std::fixed << std::setprecision(3)
               << result.entropyScore;
        if (result.entropyScore > 7.0) {
            report << " (HIGH - Potential packing/encryption)";
        } else if (result.entropyScore > 6.0) {
            report << " (MEDIUM - Possible compression)";
        } else {
            report << " (NORMAL)";
        }
        report << "\n";
    }


    if (result.packingDetected) {
        report << "• Packing Detected: YES\n";
    }


    if (result.importObfuscationLevel > 0) {
        report << "• Import Obfuscation Level: " << result.importObfuscationLevel;
        if (result.importObfuscationLevel >= 3) {
            report << " (HIGH)";
        } else if (result.importObfuscationLevel >= 2) {
            report << " (MEDIUM)";
        } else {
            report << " (LOW)";
        }
        report << "\n";
    }


    if (result.antiAnalysisScore > 0) {
        report << "• Anti-Analysis Score: " << result.antiAnalysisScore << "/10\n";
    }


    if (result.timestampManipulation) {
        report << "• Timestamp Manipulation: Detected\n";
    }


    if (result.overlayAnalysisScore > 0) {
        report << "• Overlay Analysis Score: " << result.overlayAnalysisScore << "/10\n";
    }


    if (result.structuralAnomalies > 0) {
        report << "• Structural Anomalies: " << result.structuralAnomalies << " detected\n";
    }


    if (!result.apiPatterns.empty()) {
        report << "• Suspicious API Patterns: " << result.apiPatterns.size() << "\n";
        int displayCount = 0;
        for (const auto& pattern : result.apiPatterns) {
            if (displayCount < 5) {
                report << "  - " << pattern << "\n";
                displayCount++;
            }
        }
        if (result.apiPatterns.size() > 5) {
            report << "  ... and " << (result.apiPatterns.size() - 5) << " more\n";
        }
    }


    if (!result.indicators.empty()) {
        report << "• Total Indicators: " << result.indicators.size() << "\n";


        int high = 0, medium = 0, low = 0;
        for (const auto& indicator : result.indicators) {
            if (indicator.severity >= 7) high++;
            else if (indicator.severity >= 4) medium++;
            else low++;
        }

        report << "  - High Severity: " << high << "\n";
        report << "  - Medium Severity: " << medium << "\n";
        report << "  - Low Severity: " << low << "\n";
    }


    report << "\n--- RECOMMENDATIONS ---\n";

    if (!result.recommendation.empty()) {
        report << "• " << result.recommendation << "\n";
    }

    if (riskLevel == "CRITICAL") {
        report << "• IMMEDIATE ACTION REQUIRED: Isolate and analyze in controlled environment\n";
        report << "• Do not execute this file on production systems\n";
        report << "• Consider submitting to malware analysis sandbox\n";
        report << "• Implement network monitoring if file was executed\n";
    } else if (riskLevel == "HIGH") {
        report << "• Exercise extreme caution before execution\n";
        report << "• Perform additional static and dynamic analysis\n";
        report << "• Verify file source and authenticity\n";
        report << "• Execute only in isolated environment if necessary\n";
    } else if (riskLevel == "MEDIUM") {
        report << "• Additional analysis recommended\n";
        report << "• Verify file authenticity before execution\n";
        report << "• Monitor for suspicious behavior if executed\n";
        report << "• Check against latest threat intelligence\n";
    } else {
        report << "• File appears to have low risk characteristics\n";
        report << "• Standard security precautions apply\n";
        report << "• Continue monitoring for new threat intelligence\n";
        report << "• Verify file integrity before execution\n";
    }


    if (result.packingDetected || result.importObfuscationLevel > 0 || result.antiAnalysisScore > 0) {
        report << "\n--- TECHNICAL DETAILS ---\n";
        if (result.packingDetected) {
            report << "• File appears to be packed or compressed\n";
        }
        if (result.importObfuscationLevel > 0) {
            report << "• Import table shows signs of obfuscation\n";
        }
        if (result.antiAnalysisScore > 0) {
            report << "• Anti-analysis techniques detected\n";
        }
        if (result.entropyScore > 7.0) {
            report << "• High entropy suggests encryption or compression\n";
        }
    }


    if (!result.metadata.empty()) {
        report << "\n--- METADATA ---\n";
        for (const auto& entry : result.metadata) {
            report << "• " << entry.first << ": " << entry.second << "\n";
        }
    }


    report << "\n--- END OF SUMMARY REPORT ---\n";
    report << "Generated by PE Malware Analysis Engine v4.0.0\n";
    report << "For detailed technical analysis, refer to full report above.\n\n";

    return report.str();
}

bool PEMalwareAnalysisEngine::isKnownPacker(const std::string& sectionName) {
    for (const auto& packer : KNOWN_PACKERS) {
        if (sectionName.find(packer) != std::string::npos) {
            return true;
        }
    }
    return false;
}
