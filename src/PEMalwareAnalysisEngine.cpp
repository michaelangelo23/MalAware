#include "../include/PEMalwareAnalysisEngine.h"
#include "../include/peSectionParser.h"
#include "../include/peImportExport.h"
#include <algorithm>
#include <sstream>
#include <cmath>
#include <ctime>

// Helper function to convert RVA to file offset
DWORD RvaToFileOffset_Helper(DWORD rva, PPE_FILE_INFO pFileInfo) {
    if (!pFileInfo || !pFileInfo->pNtHeader) {
        throw std::runtime_error("Invalid PE file info");
    }
    
    PIMAGE_SECTION_HEADER sectionHeader;
    int numberOfSections;
    
    if (pFileInfo->bIs64Bit) {
        auto pNtHeader64 = (PIMAGE_NT_HEADERS64)pFileInfo->pNtHeader;
        numberOfSections = pNtHeader64->FileHeader.NumberOfSections;
        sectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)pNtHeader64 + 4 + sizeof(IMAGE_FILE_HEADER) + pNtHeader64->FileHeader.SizeOfOptionalHeader);
    } else {
        auto pNtHeader32 = (PIMAGE_NT_HEADERS32)pFileInfo->pNtHeader;
        numberOfSections = pNtHeader32->FileHeader.NumberOfSections;
        sectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)pNtHeader32 + 4 + sizeof(IMAGE_FILE_HEADER) + pNtHeader32->FileHeader.SizeOfOptionalHeader);
    }
    
    // Check if RVA is in any section
    for (int i = 0; i < numberOfSections; i++) {
        DWORD sectionStart = sectionHeader[i].VirtualAddress;
        DWORD sectionEnd = sectionStart + sectionHeader[i].Misc.VirtualSize;
        
        if (rva >= sectionStart && rva < sectionEnd) {
            return rva - sectionStart + sectionHeader[i].PointerToRawData;
        }
    }
    
    // If not in any section, assume it's in headers
    if (rva < 0x1000) { // Typical header size
        return rva;
    }
    
    throw std::runtime_error("RVA not found in any section");
}

// Keep all the static vector definitions
const std::vector<std::string> PEMalwareAnalysisEngine::KNOWN_PACKERS = {
    "UPX", "ASPack", "PECompact", "NSPack", "Themida", "VMProtect", "Armadillo",
    ".aspack", ".upx", ".nsp", ".themida", ".vmp", ".arm", ".petite", ".yoda",
    "PEPACK", "PACKWIN", "ASPR", "Enigma", "ExeCryptor", "FSG", "MEW", "Molebox"
};

const std::vector<std::string> PEMalwareAnalysisEngine::ANTI_DEBUG_IMPORTS = {
    "IsDebuggerPresent", "CheckRemoteDebuggerPresent", "OutputDebugStringA",
    "OutputDebugStringW", "GetTickCount", "QueryPerformanceCounter", "timeGetTime",
    "NtQueryInformationProcess", "NtSetInformationThread", "NtQuerySystemInformation"
};

const std::vector<std::string> PEMalwareAnalysisEngine::ANTI_VM_IMPORTS = {
    "CreateFileA", "CreateFileW", "FindWindowA", "FindWindowW", "GetSystemInfo",
    "GetVersionExA", "GetVersionExW", "RegOpenKeyExA", "RegOpenKeyExW",
    "GetModuleHandleA", "GetModuleHandleW", "LoadLibraryA", "LoadLibraryW"
};

const std::vector<std::string> PEMalwareAnalysisEngine::INJECTION_IMPORTS = {
    "VirtualAllocEx", "WriteProcessMemory", "CreateRemoteThread", "OpenProcess",
    "VirtualProtectEx", "ReadProcessMemory", "SetWindowsHookExA", "SetWindowsHookExW",
    "MapViewOfFile", "UnmapViewOfFile", "NtWriteVirtualMemory", "NtAllocateVirtualMemory"
};

const std::vector<std::string> PEMalwareAnalysisEngine::CRYPTO_IMPORTS = {
    "CryptAcquireContextA", "CryptAcquireContextW", "CryptCreateHash", "CryptEncrypt",
    "CryptDecrypt", "CryptImportKey", "CryptExportKey", "BCryptOpenAlgorithmProvider",
    "BCryptEncrypt", "BCryptDecrypt", "BCryptGenerateSymmetricKey"
};

const std::vector<std::string> PEMalwareAnalysisEngine::NETWORK_IMPORTS = {
    "WSAStartup", "socket", "connect", "send", "recv", "InternetOpenA", "InternetOpenW",
    "InternetConnectA", "InternetConnectW", "HttpOpenRequestA", "HttpOpenRequestW",
    "InternetReadFile", "URLDownloadToFileA", "URLDownloadToFileW"
};

const std::vector<std::string> PEMalwareAnalysisEngine::REGISTRY_IMPORTS = {
    "RegCreateKeyExA", "RegCreateKeyExW", "RegSetValueExA", "RegSetValueExW",
    "RegDeleteKeyA", "RegDeleteKeyW", "RegDeleteValueA", "RegDeleteValueW"
};

const std::vector<std::string> PEMalwareAnalysisEngine::FILE_IMPORTS = {
    "CreateFileA", "CreateFileW", "WriteFile", "ReadFile", "DeleteFileA",
    "DeleteFileW", "MoveFileA", "MoveFileW", "CopyFileA", "CopyFileW",
    "FindFirstFileA", "FindFirstFileW", "SetFileAttributesA", "SetFileAttributesW"
};

int AnalyzeMalware(PPE_FILE_INFO pFileInfo) {
    LOGF("\n[+] MALWARE ANALYSIS ENGINE\n");
    LOGF_DEBUG("[DEBUG] Starting comprehensive malware analysis\n");
    
    if (!pFileInfo || !pFileInfo->pNtHeader) {
        LOGF("[-] ERROR: Invalid PE file info\n");
        return PE_ERROR_INVALID_PE;
    }
    
    try {
        auto result = PEMalwareAnalysisEngine::analyzeFile(pFileInfo);
        PEMalwareAnalysisEngine::logMalwareAnalysis(result);
        LOGF("[+] Malware analysis completed successfully!\n");
        return PE_SUCCESS;
    }
    catch (const std::exception& e) {
        LOGF("[-] ERROR: Malware analysis failed: %s\n", e.what());
        return PE_ERROR_PARSING;
    }
}

PEMalwareAnalysisEngine::MalwareAnalysisResult PEMalwareAnalysisEngine::analyzeFile(PPE_FILE_INFO pFileInfo) {
    MalwareAnalysisResult result = {};
    result.isSuspicious = false;
    result.riskScore = 0;
    
    if (!pFileInfo) {
        result.classification = "Analysis Failed";
        result.recommendation = "Unable to analyze file";
        return result;
    }
    
    auto packerIndicators = detectPackers(pFileInfo);
    auto antiAnalysisIndicators = detectAntiAnalysis(pFileInfo);
    auto importIndicators = detectSuspiciousImports(pFileInfo);
    auto sectionIndicators = detectSuspiciousSections(pFileInfo);
    auto obfuscationIndicators = detectObfuscation(pFileInfo);
    
    result.indicators.insert(result.indicators.end(), packerIndicators.begin(), packerIndicators.end());
    result.indicators.insert(result.indicators.end(), antiAnalysisIndicators.begin(), antiAnalysisIndicators.end());
    result.indicators.insert(result.indicators.end(), importIndicators.begin(), importIndicators.end());
    result.indicators.insert(result.indicators.end(), sectionIndicators.begin(), sectionIndicators.end());
    result.indicators.insert(result.indicators.end(), obfuscationIndicators.begin(), obfuscationIndicators.end());
    
    result.riskScore = calculateRiskScore(result.indicators);
    result.isSuspicious = result.riskScore > 30 || hasHighSeverityIndicators(result.indicators);
    result.classification = classifyMalware(result);
    result.recommendation = generateRecommendation(result.riskScore, result.classification);
    
    result.metadata["architecture"] = pFileInfo->bIs64Bit ? "x64" : "x86";
    result.metadata["total_indicators"] = std::to_string(result.indicators.size());
    result.metadata["analysis_version"] = "1.0";
    
    return result;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectPackers(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;
    if (!pFileInfo) return indicators;
    
    extern int g_NumberOfSections;
    extern PIMAGE_SECTION_HEADER g_SectionHeader;
    
    if (!g_SectionHeader) return indicators;
    
    for (int i = 0; i < g_NumberOfSections; i++) {
        char sectionName[9] = {0};
        strncpy(sectionName, (char*)g_SectionHeader[i].Name, 8);
        
        for (const auto& packer : KNOWN_PACKERS) {
            if (strstr(sectionName, packer.c_str()) != nullptr) {
                MalwareIndicator indicator;
                indicator.category = "Packer Detection";
                indicator.description = "Known packer signature detected";
                indicator.severity = 7;
                indicator.evidence = "Section name: " + std::string(sectionName) + " (matches " + packer + ")";
                indicator.isDetected = true;
                indicators.push_back(indicator);
            }
        }
    }
    
    if (isSuspiciousEntryPoint(pFileInfo)) {
        MalwareIndicator indicator;
        indicator.category = "Packer Detection";
        indicator.description = "Entry point in suspicious section";
        indicator.severity = 6;
        indicator.evidence = "Entry point not in .text section";
        indicator.isDetected = true;
        indicators.push_back(indicator);
    }
    
    return indicators;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectAntiAnalysis(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;
    if (!pFileInfo) return indicators;
    
    if (hasAntiDebugImports(pFileInfo)) {
        MalwareIndicator indicator;
        indicator.category = "Anti-Analysis";
        indicator.description = "Anti-debugging imports detected";
        indicator.severity = 8;
        indicator.evidence = "Functions like IsDebuggerPresent, CheckRemoteDebuggerPresent found";
        indicator.isDetected = true;
        indicators.push_back(indicator);
    }
    
    if (hasAntiVMImports(pFileInfo)) {
        MalwareIndicator indicator;
        indicator.category = "Anti-Analysis";
        indicator.description = "Anti-VM detection patterns found";
        indicator.severity = 7;
        indicator.evidence = "VM detection techniques present";
        indicator.isDetected = true;
        indicators.push_back(indicator);
    }
    
    return indicators;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectSuspiciousImports(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;
    if (!pFileInfo) return indicators;
    
    if (hasInjectionIndicators(pFileInfo)) {
        MalwareIndicator indicator;
        indicator.category = "Suspicious Imports";
        indicator.description = "Process injection capabilities detected";
        indicator.severity = 9;
        indicator.evidence = "VirtualAllocEx, WriteProcessMemory, CreateRemoteThread found";
        indicator.isDetected = true;
        indicators.push_back(indicator);
    }
    
    if (hasHollowingIndicators(pFileInfo)) {
        MalwareIndicator indicator;
        indicator.category = "Suspicious Imports";
        indicator.description = "Process hollowing capabilities detected";
        indicator.severity = 9;
        indicator.evidence = "Process manipulation functions found";
        indicator.isDetected = true;
        indicators.push_back(indicator);
    }
    
    return indicators;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectSuspiciousSections(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;
    if (!pFileInfo) return indicators;
    
    extern PIMAGE_SECTION_HEADER g_SectionHeader;
    
    if (!g_SectionHeader) return indicators;
    
    if (hasCodeInDataSections(pFileInfo)) {
        MalwareIndicator indicator;
        indicator.category = "Suspicious Sections";
        indicator.description = "Executable code in data sections";
        indicator.severity = 7;
        indicator.evidence = "High entropy in non-executable sections";
        indicator.isDetected = true;
        indicators.push_back(indicator);
    }
    
    return indicators;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectObfuscation(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;
    if (!pFileInfo) return indicators;
    
    extern int g_CorruptedImports;
    extern int g_InvalidDLLNames;
    
    if (g_CorruptedImports > 50 || g_InvalidDLLNames > 2) {
        MalwareIndicator indicator;
        indicator.category = "Obfuscation";
        indicator.description = "Import table obfuscation detected";
        indicator.severity = 8;
        indicator.evidence = "Corrupted import table entries detected during parsing";
        indicator.isDetected = true;
        indicators.push_back(indicator);
    }
    
    return indicators;
}

// Simplified implementations that avoid complex thunk parsing
bool PEMalwareAnalysisEngine::hasAntiDebugImports(PPE_FILE_INFO pFileInfo) {
    if (!pFileInfo || !pFileInfo->pNtHeader) {
        return false;
    }
    
    // Simple check: look for anti-debug imports by checking global import counters
    extern int g_CorruptedImports;
    extern int g_InvalidDLLNames;
    
    // If we have many corrupted imports, it might indicate anti-debugging obfuscation
    if (g_CorruptedImports > 50 || g_InvalidDLLNames > 5) {
        return true;
    }
    
    return false;
}

bool PEMalwareAnalysisEngine::hasAntiVMImports(PPE_FILE_INFO pFileInfo) {
    if (!pFileInfo || !pFileInfo->pNtHeader) {
        return false;
    }
    
    // Simplified VM detection based on import characteristics
    extern int g_CorruptedImports;
    
    // VM detection often involves unusual import patterns
    if (g_CorruptedImports > 20) {
        return true;
    }
    
    return false;
}

bool PEMalwareAnalysisEngine::hasInjectionIndicators(PPE_FILE_INFO pFileInfo) {
    if (!pFileInfo || !pFileInfo->pNtHeader) {
        return false;
    }
    
    // Check for process injection indicators by examining the import table presence
    PIMAGE_DATA_DIRECTORY importDir = nullptr;
    if (pFileInfo->bIs64Bit) {
        auto pNtHeader64 = (PIMAGE_NT_HEADERS64)pFileInfo->pNtHeader;
        importDir = &pNtHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
    } else {
        auto pNtHeader32 = (PIMAGE_NT_HEADERS32)pFileInfo->pNtHeader;
        importDir = &pNtHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
    }
    
    // Look for unusually large import tables (could indicate injection APIs)
    if (importDir && importDir->Size > 0x5000) {
        return true;
    }
    
    // Check for suspicious entry point (potential injection)
    return isSuspiciousEntryPoint(pFileInfo);
}

bool PEMalwareAnalysisEngine::hasHollowingIndicators(PPE_FILE_INFO pFileInfo) {
    if (!pFileInfo || !pFileInfo->pNtHeader) {
        return false;
    }
    
    // Process hollowing often involves suspicious entry points and section characteristics
    bool suspiciousEntry = isSuspiciousEntryPoint(pFileInfo);
    bool codeInData = hasCodeInDataSections(pFileInfo);
    
    return suspiciousEntry && codeInData;
}

bool PEMalwareAnalysisEngine::isSuspiciousEntryPoint(PPE_FILE_INFO pFileInfo) {
    if (!pFileInfo || !pFileInfo->pNtHeader) {
        return false;
    }
    
    DWORD entryPoint = 0;
    if (pFileInfo->bIs64Bit) {
        auto pNtHeader64 = (PIMAGE_NT_HEADERS64)pFileInfo->pNtHeader;
        entryPoint = pNtHeader64->OptionalHeader.AddressOfEntryPoint;
    } else {
        auto pNtHeader32 = (PIMAGE_NT_HEADERS32)pFileInfo->pNtHeader;
        entryPoint = pNtHeader32->OptionalHeader.AddressOfEntryPoint;
    }
    
    if (entryPoint == 0) {
        return true; // No entry point is suspicious
    }
    
    // Check if entry point is in .text section
    extern int g_NumberOfSections;
    extern PIMAGE_SECTION_HEADER g_SectionHeader;
    
    if (g_SectionHeader) {
        for (int i = 0; i < g_NumberOfSections; i++) {
            char sectionName[9] = {0};
            strncpy(sectionName, (char*)g_SectionHeader[i].Name, 8);
            
            // Check if entry point is in .text section
            if (strcmp(sectionName, ".text") == 0) {
                DWORD sectionStart = g_SectionHeader[i].VirtualAddress;
                DWORD sectionEnd = sectionStart + g_SectionHeader[i].Misc.VirtualSize;
                
                if (entryPoint >= sectionStart && entryPoint < sectionEnd) {
                    return false; // Entry point in .text is normal
                }
            }
        }
    }
    
    return true; // Entry point not in .text section is suspicious
}

bool PEMalwareAnalysisEngine::hasCodeInDataSections(PPE_FILE_INFO pFileInfo) {
    if (!pFileInfo || !pFileInfo->pNtHeader) {
        return false;
    }
    
    extern int g_NumberOfSections;
    extern PIMAGE_SECTION_HEADER g_SectionHeader;
    
    if (!g_SectionHeader) {
        return false;
    }
    
    for (int i = 0; i < g_NumberOfSections; i++) {
        char sectionName[9] = {0};
        strncpy(sectionName, (char*)g_SectionHeader[i].Name, 8);
        
        // Check for executable flags in non-code sections
        DWORD characteristics = g_SectionHeader[i].Characteristics;
        bool isExecutable = (characteristics & IMAGE_SCN_MEM_EXECUTE) != 0;
        bool isDataSection = (strcmp(sectionName, ".data") == 0 || 
                            strcmp(sectionName, ".rdata") == 0 ||
                            strcmp(sectionName, ".rsrc") == 0);
        
        if (isDataSection && isExecutable) {
            return true;
        }
        
        // Also check for high entropy in data sections (could indicate packed code)
        if (isDataSection && g_SectionHeader[i].SizeOfRawData > 0) {
            BYTE* sectionData = (BYTE*)((DWORD_PTR)pFileInfo->pDosHeader + g_SectionHeader[i].PointerToRawData);
            double entropy = calculateSectionEntropy(sectionData, g_SectionHeader[i].SizeOfRawData);
            if (entropy > 7.0) { // High entropy in data section could indicate hidden code
                return true;
            }
        }
    }
    
    return false;
}

bool PEMalwareAnalysisEngine::hasSuspiciousStrings(PPE_FILE_INFO pFileInfo) {
    (void)pFileInfo; // Suppress unused parameter warning
    return false; // Placeholder implementation
}

// Helper function to calculate entropy
double PEMalwareAnalysisEngine::calculateSectionEntropy(const BYTE* data, size_t size) {
    if (!data || size == 0) return 0.0;
    
    unsigned int frequency[256] = {0};
    for (size_t i = 0; i < size; i++) {
        frequency[data[i]]++;
    }
    
    double entropy = 0.0;
    for (int i = 0; i < 256; i++) {
        if (frequency[i] > 0) {
            double probability = (double)frequency[i] / size;
            entropy -= probability * log2(probability);
        }
    }
    
    return entropy;
}

int PEMalwareAnalysisEngine::calculateRiskScore(const std::vector<MalwareIndicator>& indicators) {
    int score = 0;
    for (const auto& indicator : indicators) {
        if (indicator.isDetected) {
            if (indicator.category == "Packer Detection") {
                score += PACKER_WEIGHT;
            } else if (indicator.category == "Anti-Analysis") {
                score += ANTI_ANALYSIS_WEIGHT;
            } else if (indicator.category == "Suspicious Imports") {
                score += SUSPICIOUS_IMPORTS_WEIGHT;
            } else if (indicator.category == "Suspicious Sections") {
                score += SUSPICIOUS_SECTIONS_WEIGHT;
            } else if (indicator.category == "Obfuscation") {
                score += OBFUSCATION_WEIGHT;
            }
        }
    }
    return std::min(score, 100); 
}

std::string PEMalwareAnalysisEngine::classifyMalware(const MalwareAnalysisResult& result) {
    if (result.riskScore <= 10) {
        return "Clean/Low Risk";
    } else if (result.riskScore <= 40) {
        return "Suspicious";
    } else if (result.riskScore <= 70) {
        return "Likely Malware";
    } else {
        return "High Risk Malware";
    }
}

std::string PEMalwareAnalysisEngine::generateRecommendation(int riskScore, const std::string& classification) {
    (void)classification; // Suppress unused parameter warning
    
    if (riskScore <= 10) {
        return "File appears clean. Standard security practices apply.";
    } else if (riskScore <= 40) {
        return "Exercise caution. Consider additional analysis with behavioral tools.";
    } else if (riskScore <= 70) {
        return "High risk file. Recommend sandboxed analysis and avoid execution.";
    } else {
        return "DANGEROUS: Do not execute. Quarantine and analyze in isolated environment.";
    }
}

void PEMalwareAnalysisEngine::logMalwareAnalysis(const MalwareAnalysisResult& analysisResult) {
    LOGF("\tRisk Score: %d/100\n", analysisResult.riskScore);
    LOGF("\tClassification: %s\n", analysisResult.classification.c_str());
    LOGF("\tSuspicious: %s\n", analysisResult.isSuspicious ? "YES" : "NO");
    
    if (!analysisResult.indicators.empty()) {
        LOGF("\tThreat Indicators (%zu found):\n", analysisResult.indicators.size());
        for (const auto& indicator : analysisResult.indicators) {
            if (indicator.isDetected) {
                LOGF("\t\t[%s] %s (Severity: %d/10)\n", 
                     indicator.category.c_str(),
                     indicator.description.c_str(),
                     indicator.severity);
                if (!indicator.evidence.empty()) {
                    LOGF("\t\t    Evidence: %s\n", indicator.evidence.c_str());
                }
            }
        }
    } else {
        LOGF("\tThreat Indicators: None detected\n");
    }
    
    LOGF("\tRecommendation: %s\n", analysisResult.recommendation.c_str());
}

bool PEMalwareAnalysisEngine::hasHighSeverityIndicators(const std::vector<MalwareIndicator>& indicators) {
    for (const auto& indicator : indicators) {
        if (indicator.severity >= 8) {
            return true;
        }
    }
    return false;
}

// Placeholder functions for API pattern detection
std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectEntropyAnomalies(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;
    
    if (!pFileInfo || !pFileInfo->pNtHeader) {
        return indicators;
    }
    
    PIMAGE_SECTION_HEADER pSectionHeader;
    int numberOfSections;
    
    if (pFileInfo->bIs64Bit) {
        auto pNtHeader64 = (PIMAGE_NT_HEADERS64)pFileInfo->pNtHeader;
        numberOfSections = pNtHeader64->FileHeader.NumberOfSections;
        pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)pNtHeader64 + 4 + sizeof(IMAGE_FILE_HEADER) + pNtHeader64->FileHeader.SizeOfOptionalHeader);
    } else {
        auto pNtHeader32 = (PIMAGE_NT_HEADERS32)pFileInfo->pNtHeader;
        numberOfSections = pNtHeader32->FileHeader.NumberOfSections;
        pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)pNtHeader32 + 4 + sizeof(IMAGE_FILE_HEADER) + pNtHeader32->FileHeader.SizeOfOptionalHeader);
    }
    
    std::vector<double> sectionEntropies;
    std::vector<std::string> sectionNames;
    
    // Calculate entropy for each section
    for (int i = 0; i < numberOfSections; i++) {
        std::string sectionName(reinterpret_cast<const char*>(pSectionHeader[i].Name), 8);
        sectionName = sectionName.substr(0, sectionName.find('\0')); // Remove null padding
        sectionNames.push_back(sectionName);
        
        // Simple entropy calculation (simplified version)
        const uint8_t* sectionData = reinterpret_cast<const uint8_t*>(pFileInfo->pDosHeader) + pSectionHeader[i].PointerToRawData;
        size_t sectionSize = pSectionHeader[i].SizeOfRawData;
        
        if (sectionSize == 0) {
            sectionEntropies.push_back(0.0);
            continue;
        }
        
        // Calculate byte frequency
        std::vector<int> frequency(256, 0);
        for (size_t j = 0; j < sectionSize && j < 65536; j++) { // Limit to 64KB for performance
            frequency[sectionData[j]]++;
        }
        
        // Calculate entropy
        double entropy = 0.0;
        size_t totalBytes = std::min(sectionSize, static_cast<size_t>(65536));
        for (int freq : frequency) {
            if (freq > 0) {
                double probability = static_cast<double>(freq) / totalBytes;
                entropy -= probability * log2(probability);
            }
        }
        
        sectionEntropies.push_back(entropy);
    }
    
    // Analyze entropy patterns
    if (!sectionEntropies.empty()) {
        // Check for very high entropy sections (possible packing/encryption)
        for (size_t i = 0; i < sectionEntropies.size(); i++) {
            if (sectionEntropies[i] > 7.5) {
                MalwareIndicator indicator;
                indicator.category = "High Entropy Section";
                indicator.description = "Section has very high entropy suggesting encryption or packing";
                indicator.evidence = "Section '" + sectionNames[i] + "' has entropy " + std::to_string(sectionEntropies[i]);
                indicator.severity = 7;
                indicators.push_back(indicator);
            }
        }
        
        // Check for entropy variance (mixed packed/unpacked content)
        double minEntropy = *std::min_element(sectionEntropies.begin(), sectionEntropies.end());
        double maxEntropy = *std::max_element(sectionEntropies.begin(), sectionEntropies.end());
        double entropyVariance = maxEntropy - minEntropy;
        
        if (entropyVariance > 4.0 && maxEntropy > 6.0) {
            MalwareIndicator indicator;
            indicator.category = "Entropy Variance";
            indicator.description = "Large entropy variance between sections";
            indicator.evidence = "Entropy range: " + std::to_string(minEntropy) + " - " + std::to_string(maxEntropy);
            indicator.severity = 6;
            indicators.push_back(indicator);
        }
        
        // Check for executable sections with high entropy
        for (int i = 0; i < numberOfSections; i++) {
            if ((pSectionHeader[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) && sectionEntropies[i] > 6.5) {
                MalwareIndicator indicator;
                indicator.category = "High Entropy Executable";
                indicator.description = "Executable section has suspiciously high entropy";
                indicator.evidence = "Executable section '" + sectionNames[i] + "' entropy: " + std::to_string(sectionEntropies[i]);
                indicator.severity = 8;
                indicators.push_back(indicator);
            }
        }
    }
    
    return indicators;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectTimestampManipulation(PPE_FILE_INFO pFileInfo) {
    (void)pFileInfo;
    return std::vector<MalwareIndicator>();
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectOverlayAnomalies(PPE_FILE_INFO pFileInfo) {
    (void)pFileInfo;
    return std::vector<MalwareIndicator>();
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectAPIPatterns(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;
    
    if (!pFileInfo) {
        return indicators;
    }
    
    // Define suspicious API patterns commonly used by malware
    const std::vector<std::string> ANTI_DEBUG_APIS = {
        "IsDebuggerPresent", "CheckRemoteDebuggerPresent", "NtQueryInformationProcess",
        "OutputDebugStringA", "OutputDebugStringW", "GetTickCount", "QueryPerformanceCounter"
    };
    
    const std::vector<std::string> PROCESS_MANIPULATION_APIS = {
        "CreateProcess", "CreateRemoteThread", "WriteProcessMemory", "ReadProcessMemory",
        "VirtualAllocEx", "VirtualProtectEx", "SetWindowsHookEx", "EnumProcesses"
    };
    
    const std::vector<std::string> NETWORK_APIS = {
        "InternetOpen", "InternetConnect", "HttpOpenRequest", "WinHttpOpen",
        "socket", "connect", "send", "recv", "WSAStartup"
    };
    
    const std::vector<std::string> CRYPTO_APIS = {
        "CryptAcquireContext", "CryptCreateHash", "CryptHashData", "CryptEncrypt",
        "CryptDecrypt", "CryptGenKey", "CryptExportKey", "CryptImportKey"
    };
    
    const std::vector<std::string> PERSISTENCE_APIS = {
        "RegOpenKey", "RegSetValue", "RegCreateKey", "CreateService",
        "OpenSCManager", "StartService", "CreateFile", "WriteFile"
    };
    
    // This is a simplified implementation - in a real system, you would
    // parse the import table and check each imported function
    // For now, we'll use a heuristic based on the import table corruption
    // we already detect
    
    extern int g_CorruptedImports;
    extern int g_InvalidDLLNames;
    
    // If we have corrupted imports, it might indicate API obfuscation
    if (g_CorruptedImports > 0) {
        MalwareIndicator indicator;
        indicator.category = "API Obfuscation";
        indicator.description = "Import table corruption detected - possible API hiding";
        indicator.evidence = "Corrupted import entries: " + std::to_string(g_CorruptedImports);
        indicator.severity = 7;
        indicators.push_back(indicator);
    }
    
    // Check for invalid DLL names which might indicate dynamic loading obfuscation
    if (g_InvalidDLLNames > 3) {
        MalwareIndicator indicator;
        indicator.category = "Dynamic Loading";
        indicator.description = "Multiple invalid DLL names suggest dynamic API resolution";
        indicator.evidence = "Invalid DLL names: " + std::to_string(g_InvalidDLLNames);
        indicator.severity = 6;
        indicators.push_back(indicator);
    }
    
    return indicators;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectStructuralAnomalies(PPE_FILE_INFO pFileInfo) {
    (void)pFileInfo;
    return std::vector<MalwareIndicator>();
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectStringAnomalies(PPE_FILE_INFO pFileInfo) {
    std::vector<MalwareIndicator> indicators;
    
    if (!pFileInfo || !pFileInfo->pDosHeader) {
        return indicators;
    }
    
    // Define suspicious string patterns commonly found in malware
    const std::vector<std::string> SUSPICIOUS_STRINGS = {
        "payload", "exploit", "shell", "backdoor", "trojan", "virus",
        "keylog", "stealer", "botnet", "rootkit", "ransomware", "miner",
        "debug.exe", "taskkill", "net user", "reg add", "schtasks",
        "powershell", "cmd.exe", "rundll32", "regsvr32", "certutil"
    };
    
    const std::vector<std::string> OBFUSCATION_PATTERNS = {
        "aaaaaaa", "1111111", "xxxxxxx", "0000000",
        "base64", "decode", "encode", "decrypt", "unpack"
    };
    
    // Search for strings in the file (simplified approach)
    const char* fileData = reinterpret_cast<const char*>(pFileInfo->pDosHeader);
    size_t fileSize = 0; // We don't have file size readily available, estimate from sections
    
    // Calculate approximate file size from sections
    if (pFileInfo->pNtHeader) {
        PIMAGE_SECTION_HEADER pSectionHeader;
        int numberOfSections;
        
        if (pFileInfo->bIs64Bit) {
            auto pNtHeader64 = (PIMAGE_NT_HEADERS64)pFileInfo->pNtHeader;
            numberOfSections = pNtHeader64->FileHeader.NumberOfSections;
            pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)pNtHeader64 + 4 + sizeof(IMAGE_FILE_HEADER) + pNtHeader64->FileHeader.SizeOfOptionalHeader);
        } else {
            auto pNtHeader32 = (PIMAGE_NT_HEADERS32)pFileInfo->pNtHeader;
            numberOfSections = pNtHeader32->FileHeader.NumberOfSections;
            pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)pNtHeader32 + 4 + sizeof(IMAGE_FILE_HEADER) + pNtHeader32->FileHeader.SizeOfOptionalHeader);
        }
        
        // Find the last section to estimate file size
        for (int i = 0; i < numberOfSections; i++) {
            size_t sectionEnd = pSectionHeader[i].PointerToRawData + pSectionHeader[i].SizeOfRawData;
            if (sectionEnd > fileSize) {
                fileSize = sectionEnd;
            }
        }
    }
    
    // Limit scanning to reasonable size (first 1MB)
    if (fileSize > 1024 * 1024) {
        fileSize = 1024 * 1024;
    }
    
    int suspiciousStringCount = 0;
    int obfuscationStringCount = 0;
    
    // Simple string scanning (looking for printable sequences)
    std::string currentString;
    for (size_t i = 0; i < fileSize; i++) {
        char c = fileData[i];
        if (c >= 32 && c <= 126) { // Printable ASCII
            currentString += c;
        } else {
            if (currentString.length() >= 4) {
                // Convert to lowercase for comparison
                std::string lowerStr = currentString;
                std::transform(lowerStr.begin(), lowerStr.end(), lowerStr.begin(), ::tolower);
                
                // Check for suspicious strings
                for (const auto& suspiciousStr : SUSPICIOUS_STRINGS) {
                    if (lowerStr.find(suspiciousStr) != std::string::npos) {
                        suspiciousStringCount++;
                        break;
                    }
                }
                
                // Check for obfuscation patterns
                for (const auto& obfPattern : OBFUSCATION_PATTERNS) {
                    if (lowerStr.find(obfPattern) != std::string::npos) {
                        obfuscationStringCount++;
                        break;
                    }
                }
            }
            currentString.clear();
        }
    }
    
    // Create indicators based on findings
    if (suspiciousStringCount > 2) {
        MalwareIndicator indicator;
        indicator.category = "Suspicious Strings";
        indicator.description = "Multiple suspicious strings found in file";
        indicator.evidence = "Found " + std::to_string(suspiciousStringCount) + " suspicious string patterns";
        indicator.severity = (suspiciousStringCount > 5) ? 8 : 6;
        indicators.push_back(indicator);
    }
    
    if (obfuscationStringCount > 1) {
        MalwareIndicator indicator;
        indicator.category = "String Obfuscation";
        indicator.description = "Possible string obfuscation patterns detected";
        indicator.evidence = "Found " + std::to_string(obfuscationStringCount) + " obfuscation indicators";
        indicator.severity = 7;
        indicators.push_back(indicator);
    }
    
    return indicators;
}

std::vector<PEMalwareAnalysisEngine::MalwareIndicator> PEMalwareAnalysisEngine::detectSectionAnomalies(PPE_FILE_INFO pFileInfo) {
    (void)pFileInfo;
    return std::vector<MalwareIndicator>();
}

std::string PEMalwareAnalysisEngine::generateDetailedReport(const MalwareAnalysisResult& result) {
    std::stringstream report;
    
    report << "\n=== DETAILED MALWARE ANALYSIS REPORT ===\n";
    std::time_t now = std::time(nullptr);
    report << "Analysis Date: " << std::ctime(&now);
    report << "Risk Score: " << result.riskScore << "/100\n";
    report << "Classification: " << result.classification << "\n";
    report << "Suspicious: " << (result.isSuspicious ? "YES" : "NO") << "\n\n";
    
    if (!result.indicators.empty()) {
        report << "THREAT INDICATORS FOUND (" << result.indicators.size() << "):\n";
        report << "========================================\n";
        
        for (size_t i = 0; i < result.indicators.size(); i++) {
            const auto& indicator = result.indicators[i];
            
            report << "[" << (i + 1) << "] " << indicator.category << "\n";
            report << "    Severity: " << indicator.severity << "/10\n";
            report << "    Description: " << indicator.description << "\n";
            report << "    Evidence: " << indicator.evidence << "\n";
            
            // Add risk assessment
            if (indicator.severity >= 8) {
                report << "    Risk Level: HIGH\n";
            } else if (indicator.severity >= 6) {
                report << "    Risk Level: MEDIUM\n";
            } else {
                report << "    Risk Level: LOW\n";
            }
            report << "\n";
        }
    } else {
        report << "NO THREAT INDICATORS DETECTED\n";
        report << "This file appears to be clean based on current analysis.\n\n";
    }
    
    // Add recommendations
    report << "RECOMMENDATIONS:\n";
    report << "================\n";
    
    if (result.riskScore >= 70) {
        report << "🚨 HIGH RISK - This file is likely malicious\n";
        report << "   • DO NOT EXECUTE this file\n";
        report << "   • Isolate the file immediately\n";
        report << "   • Submit to antivirus vendors for analysis\n";
        report << "   • Consider forensic analysis\n";
    } else if (result.riskScore >= 40) {
        report << "⚠️  MEDIUM RISK - This file shows suspicious characteristics\n";
        report << "   • Exercise extreme caution\n";
        report << "   • Execute only in isolated environment\n";
        report << "   • Monitor system behavior if executed\n";
        report << "   • Scan with multiple antivirus engines\n";
    } else {
        report << "✅ LOW RISK - This file appears relatively safe\n";
        report << "   • File shows minimal suspicious indicators\n";
        report << "   • Standard security precautions recommended\n";
        report << "   • Regular antivirus scanning advised\n";
    }
    
    report << "\n";
    report << "TECHNICAL ANALYSIS SUMMARY:\n";
    report << "===========================\n";
    
    // Count indicators by type
    std::map<std::string, int> indicatorTypes;
    for (const auto& indicator : result.indicators) {
        indicatorTypes[indicator.category]++;
    }
    
    if (!indicatorTypes.empty()) {
        report << "Indicators by Category:\n";
        for (const auto& pair : indicatorTypes) {
            report << "  • " << pair.first << ": " << pair.second << " finding(s)\n";
        }
    }
    
    report << "\nAnalysis Confidence: ";
    if (result.indicators.size() >= 3) {
        report << "HIGH (Multiple indicators detected)\n";
    } else if (result.indicators.size() >= 1) {
        report << "MEDIUM (Some indicators detected)\n";
    } else {
        report << "LOW (Limited indicators available)\n";
    }
    
    report << "\nNote: This analysis is based on static file analysis.\n";
    report << "Dynamic analysis in a sandbox environment is recommended\n";
    report << "for comprehensive threat assessment.\n";
    
    report << "\n=== END OF DETAILED REPORT ===\n";
    
    return report.str();
}

std::string PEMalwareAnalysisEngine::generateSummaryReport(const MalwareAnalysisResult& result) {
    (void)result;
    return "Summary report not implemented";
}

bool PEMalwareAnalysisEngine::isKnownPacker(const std::string& sectionName) {
    for (const auto& packer : KNOWN_PACKERS) {
        if (sectionName.find(packer) != std::string::npos) {
            return true;
        }
    }
    return false;
}
